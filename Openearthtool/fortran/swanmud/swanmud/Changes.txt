The changes I made:

1) comment this lines:
in: swancom1.for
          CALL SWTSTA(110)                                                40.23
          IF ( IMUD.GE.1 ) THEN                                          !40.61mud^M
!          COMPSPC(:,:,JKWVR) = 0.^M                                     !40.61mud^M
!          COMPSPC(:,:,JKWVI) = 0.^M                                     !40.61mud^M
          CALL SWAPARM( COMPDA(1,JDP2), KWAVE, CGO, SPCSIG ,             !40.61mud^M
----------------------------------------------------------------------------------------done (1)																
2) force the code to update COMPSPC each time step once
in swancom1.for:
Change the type of FIRST from logical to integer
!FIRST indicates whether SWOMPU is called for 1st time                    40.61mud,!40.61SM
!      LOGICAL, SAVE :: FIRST  = .true.                                   !40.61SM  
!FIRST indicates whether SWOMPU is called only once for each iteration    !40.61SM
      INTEGER, SAVE :: FIRST  = 1                                         !40.61SM

and change this piece of code:

! When mud present, calculate complex wave number FOR ALL GRID CELLS,
! although this subroutine SWOMPU does things for only one cell.
!
! BUT ONLY ONCE for each time step
!      IF ( IMUD.GE.1  .AND. ITER==1 .AND. SWPDIR==1 .and. FIRST) THEN    !40.61mud
      IF ( IMUD.GE.1  .AND. ITER==1 .AND. SWPDIR==1                       !40.61SM
     &                            .AND. FIRST.eq.IT ) THEN                !40.61SM        
	!write(*,*) IMUD,ITER,SWPDIR,FIRST
!	FIRST = .false.	                                                  !40.61SM 
        FIRST=IT+1
!        write(*,*) 'mud version calls always SPROSDM instead of SPROSD'  !40.61SM
!
! read MUDFile with dispersion relation or ...
!
      disperr = PMUD(6)
      disperi = PMUD(7)
      IF     (disperr==-1 .or. disperi==-1) THEN
      write(*,*) 'Reading mud dispersion relation from "MUDFile" ...'
      
      IF     (disperr==-1 .and. .not.disperi==-1) THEN
          write(*,*) 'for MUDFile disperr and disperi should be -1'
          stop
      ENDIF
      IF     (.not.disperr==-1 .and. disperi==-1) THEN
          write(*,*) 'for MUDFile disperr and disperi should be -1'
          stop
      ENDIF
      
      CALL RESTOREM(SPCSIG,  KGRPNT, XCGRID, YCGRID ,
     &              COMPSPC(1,1,JKWVR),COMPSPC(1,1,JKWVI))
!
! ... or calculate + save one
!
      ELSE
!      write(*,*) 'Calculating mud dispersion relation ...'              !40.61SM
      CALL SWMUDK(COMPDA (1,  JDP2 ),                                    !40.61mud
     &            COMPDA (1, JMUDL2),SPCSIG,ISSTOP,IX,IY,                !40.61mud
     &            COMPSPC(1,1,JKWVR),                                    !40.61mud
     &            COMPSPC(1,1,JKWVI))                                    !40.61mud
!
!     write (x,y,sigma) matrices of KREAL AND KIMAG to SPEC file
      IF (NSTATC .EQ. 0) THEN                                             !40.61SM
        CALL BACKUPM(SPCSIG,  KGRPNT, XCGRID, YCGRID ,
     &             COMPSPC(1,1,JKWVR),COMPSPC(1,1,JKWVI))
      write(*,*) 'Saved calculated mud dispersion relation to "MUDFile"'      
      ENDIF                                                              !40.61SM   
      ENDIF
      ENDIF                                                              !40.61mud
!m!   
      IF (PROPSL.EQ.3 .AND. NSTATC.GT.0) THEN                             33.08

----------------------------------------------------------------------------------------done (2)

3) Term 3 and term1 according to ASCE paper
   factoring the terms to slightly decreasing the calculations costs

----------------------------------------------------------------------------------------done (3)

4) need to improve soloutions, the refinements are really time consuming
   To do this, I divided the whole dispersion equation by (coshkh*coshmd)
   I checked Muller, Secant and Newton method: usually Newton is more economical
   Provide the second and third initial numbers of Muller using Newton can help its accuracy
   Note that Newton method requires the derivative of dispersion equation too
   Later tests showed that Newton method is 10% slower than Muller-newton subroutine in most of my tests
   Also note that my Muller function needs 3 less input compared to that of ISML library; so I modified the call commands
   With these changes, there is no need to call improve_with_argand which is really time-consuming
   so:
   in
	DKDEWIT1995 
	DKDELFT2008
	CALL DZANLY -> CALL MullerNewton or CALL NewtonRoots

   in:
	DKDALR1978   
	CALL DZANLY -> CALL MULLER  (needs to migrate to MullerNewton soon)


   in:
	FUNCTION DFDEWIT (K)
	FUNCTION DFKRAN (K)         The numerics is slightly numerics changed

   The following functions are added (Basically for Newton Method; because it needs the derivative of the function)
	FUNCTION DFDEWITder (K)
	FUNCTION DFKRANder (K)        

   Also:
	SUBROUTINE DARGAND(kmudD)   
	FUNCTION DFKRANnu0(kr)          => obsolete now
    
----------------------------------------------------------------------------------------done (4)

5) start guess: use previous time step (to reduce comutaional cost of DSV subroutine)
	Usually converges with less than 4 itteration in current setup;
        Changing the initial cindition to previous time step save less than 1% of effort
        needed for iterations; so not implemented (it increases persistance of probable
        divergence)

---------------------------------------------------------------------------------------- done(5)

6) The output of first time step for Ki is NAN
in SWMUD.for, COMPSPC (KWAVE) is zero when SWKMEAN is called; so we need to change
               IF (ETOT.LE.0) THEN
to
               IF (ETOT.LE.0. .or. EKTOT.LE.0.) THEN                          !40.61SM
to avoid division by zero
However, if we initilize COMPSPC to right values from the first time step in SWANMAIN, 
we do not need to do that. To do that, the following codes were added to SWANMAIN.for
      INTEGER              :: IX, IY                                      !40.61SM
.
.
.
            IF ( IT.EQ.IT0 .AND. .NOT.ALLOCATED(OURQT) ) THEN             40.51 40.31
               ALLOCATE (OURQT(MAX_OUTP_REQ))                             40.51 40.30
               OURQT = -9999.                                             40.51 40.30
            ENDIF                                                         40.00
!
!           --- wave number should be updated for the first time          !40.61SM
!               step before performing output request                     !40.61SM
            IF ( IT.EQ.IT0 )  then                                        !40.61SM    
               Do IX=1, MXC                                               !40.61SM  
                  DO IY=1, MYC                                            !40.61SM  
                      CALL SWMUDK(COMPDA (1,  JDP2 ),                     !40.61SM
     &                  COMPDA (1, JMUDL2),SPCSIG,MSC,IX,IY,              !40.61SM
     &                  COMPSPC(1,1,JKWVR),                               !40.61SM
     &                  COMPSPC(1,1,JKWVI))                               !40.61SM
                  ENDDO                                                   !40.61SM
               ENDDO                                                      !40.61SM
            ENDIF                                                         !40.61SM
! 
            SAVITE = ITEST                                                30.21
            IF (IOUTES .GT. ITEST) ITEST = IOUTES

!           --- synchronize nodes

            CALL SWSYNC                                                   40.30
            IF (STPNOW()) RETURN                                          40.30

!           --- carry out the output requests
----------------------------------------------------------------------------------------done(6)

		  
