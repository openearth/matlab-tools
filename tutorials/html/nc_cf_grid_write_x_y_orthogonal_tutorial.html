
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>nc_cf_grid_write_x_y_orthogonal_tutorial</title>
      <meta name="generator" content="MATLAB 7.10">
      <meta name="date" content="2010-06-22">
      <meta name="m-file" content="nc_cf_grid_write_x_y_orthogonal_tutorial">
      <link type="text/css" href="script/css/jquery-ui-1.7.2.custom.css" rel="stylesheet">
      <link type="text/css" href="script/css/jquery.collapsible.css" rel="stylesheet"><script type="text/javascript" src="script/js/jquery-1.3.2.min.js"></script><script type="text/javascript" src="script/js/jquery-ui-1.7.2.custom.min.js"></script><script type="text/javascript" src="script/js/matlab2collapsible.js"></script><script type="text/javascript" src="script/js/jquery.collapsible.js"></script><script type="text/javascript" src="script/js/matlabhelp.js"></script><script src="http://www.google.com/jsapi?key=ABQIAAAA9KO06BPsmsvzw4PogoawhRRxYg1slSMvxuda9W0Kolc-SbeLlhQGHwE9W-XlCfe8WtZh74R56zOChQ"></script><script type="text/javascript" src="script/js/googleEarthApi.js"></script><script type="text/javascript">
    $(document).ready(function ()
      {
        // Copy content
	copycontent();

	// validate href of links to matlab tutorials
	matlabpreparehelprefs();

  	// Accordion
  	collapsible($(".collapsible"));
	
	// googleearth($(".geapi"));
	currentGeApiDiv = $(".geapi");	
      });
    </script><link type="text/css" href="script/css/matlabcode.css" rel="stylesheet">
   </head>
   <body LINK="#48339F" VLINK="#48339F" ALINK="#48339F">
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Create netCDF-CF of orthogonal x-y grid</a></li>
               <li><a href="#2">Define meta-info: global: x,y sticks &gt; lat,lon matrices</a></li>
               <li><a href="#3">Define dimensions/coordinates</a></li>
               <li><a href="#4">Define variable (define some data)</a></li>
               <li><a href="#5">1.a Create netCDF file</a></li>
               <li><a href="#6">1.b Add overall meta info</a></li>
               <li><a href="#7">2.a Create matrix span dimensions</a></li>
               <li><a href="#8">3.a Create coordinate vectors: x and y</a></li>
               <li><a href="#9">3.b Create coordinate variables: coordinate system: epsg</a></li>
               <li><a href="#10">3.c Create coordinate variables: longitude</a></li>
               <li><a href="#11">3.d Create coordinate variables: latitude</a></li>
               <li><a href="#12">3.e Create coordinate variables: coordinate system: WGS84 default</a></li>
               <li><a href="#13">4   Create dependent variable</a></li>
               <li><a href="#14">5.a Create all variables with attributes</a></li>
               <li><a href="#15">5.b Fill all variables</a></li>
               <li><a href="#16">6   Check file summary</a></li>
               <li><a href="#17">7.a Load the data: using the variable names from nc_dump</a></li>
               <li><a href="#18">7.b Load the data: using standard_names and coordinate attribute</a></li>
               <li><a href="#19">7.c Load the data: using a dedicated function developed for grids</a></li>
            </ul>
         </div>
         <div class="collapsible">
            <div>
               <h2><a name="1">Create netCDF-CF of orthogonal x-y grid</a></h2>
               <div><pre>example of how to make a netCDF file with CF conventions of a
variable that is defined on a grid that is orthogonal
in a x-y coordinate system. In this special case
the dimensions coincide with the x-y coordinate axes.
The associated lat-lon coordinate matrices are curvi-linear.</pre><pre>This case is described in:
http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
as "Horizontal Coordinate Reference Systems, Grid Mappings, and Projections".</pre><pre>An example of an orthogonal x,y grid is for instance
a data product defined on an otrhogonal grid in a certain
local geograhic projection by programs like arcGIS. For each
vertex in this grid a the lat,lon values need to be calculated
to project it on the globe (e.g. Google Earth).</pre><pre>  ^ latitude (degrees_north)           ^ y(m)
  |         x                          |
  | ncols /   \                        |        ncols
  |     /  /\   \              coordinate	  +------+
  |   /   /15\    \          transformation
  |  x  /10   \     \       &lt;==============&gt;	 +--------+
  |    &lt;5     14\     \                |      |05 10 15|  +
  |     \   9    \      \              |      |        |  |
  |      \4       \      |             |      |04 09 14|  |
  |       \        \     |             |      |        |  |
  |        )3  8  xx)    | nrows       |      |03 08 xx|  | nrows
  |       /        /     |             |      |        |  |
  |      /2       /      |             |      |02 07 12|  |
  |     /   7    /      /              |      |        |  |
  |    &lt;1     12/     /                |      |01 06 11|  +
  |     \6    /     /                  |      +--------+
  |       \11/    /                    |
  |        \/   x                      |
  |                                    |
  +----------------------&gt; longitude   +----------------------&gt; x
                      (degrees_east)                          (m)</pre><p>Note that ncBrowse does not contain plot support for curvi-linear grids, so ncBrowse will display the same rectangular plot
                     as for the netCDF file created by NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL, albeit with different axes annotations (col/row
                     instead of lat/lon).
                  </p><pre class="codeinput"><span class="comment">%See also: SNCTOOLS, NC_CF_GRID, NC_CF_GRID_WRITE,</span>
<span class="comment">%          NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL,</span>
<span class="comment">%          NC_CF_GRID_WRITE_LAT_LON_CURVILINEAR_TUTORIAL,</span>
<span class="comment">%          NC_CF_GRID_WRITE_X_Y_CURVILINEAR_TUTORIAL,</span>
<span class="comment">%          NC_CF_STATIONTIMESERIES</span>
<span class="comment">%</span>
<span class="comment">% This tool is part of &lt;a href="http://www.OpenEarth.eu"&gt;OpenEarthTools&lt;/a&gt; under the &lt;a href="http://www.gnu.org/licenses/gpl.html"&gt;GPL&lt;/a&gt; license.</span>
</pre></div>
            </div>
            <div>
               <h2><a name="2">Define meta-info: global: x,y sticks &gt; lat,lon matrices</a></h2>
               <div><pre class="codeinput">   OPT.title                  = <span class="string">''</span>;
   OPT.institution            = <span class="string">''</span>;
   OPT.source                 = <span class="string">''</span>;
   OPT.history                = [<span class="string">'tranformation to netCDF: $HeadURL: https://repos.deltares.nl/repos/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_orthogonal_tutorial.m $'</span>];
   OPT.references             = <span class="string">''</span>;
   OPT.email                  = <span class="string">''</span>;
   OPT.comment                = <span class="string">''</span>;
   OPT.version                = <span class="string">''</span>;
   OPT.acknowledge            =[<span class="string">'These data can be used freely for research purposes provided that the following source is acknowledged: '</span>,OPT.institution];
   OPT.disclaimer             = <span class="string">'This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'</span>;
</pre></div>
            </div>
            <div>
               <h2><a name="3">Define dimensions/coordinates</a></h2>
               <div><pre class="codeinput">   OPT.x                      = [400 500 600].*1e3;
   OPT.y                      = [5500:100:5900].*1e3;

  [x,y]                       = ndgrid(OPT.x,OPT.y);

   OPT.ncols                  = length(OPT.x);
   OPT.nrows                  = length(OPT.y);
   OPT.lat_type               = <span class="string">'single'</span>; <span class="comment">% 'single', 'double' for high-resolution data (eps 1m)</span>
   OPT.lon_type               = <span class="string">'single'</span>; <span class="comment">% 'single', 'double' for high-resolution data (eps 1m)</span>

   OPT.epsg.code              = 32631; <span class="comment">% epsg code of local projection</span>
   OPT.wgs84.code             = 4326;  <span class="comment">% epsg code of global grid</span>
   <span class="comment">% http://www.epsg-registry.org/</span>
   <span class="comment">% in the case of a grid defined in a local x-y</span>
   <span class="comment">% projection, the properties of the grid in a WGS84</span>
   <span class="comment">% lat,lon system do not have to be specified here, but</span>
   <span class="comment">% can be retrieved from the log of the coordinate</span>
   <span class="comment">% transformation carried out by convertCoordinates.</span>
   <span class="comment">% get (lat,lon) associated with each vertex (x,y), note order [OPT.lon,OPT.lat ...</span>

  [OPT.lon,OPT.lat,log]       = convertCoordinates(x,y,<span class="string">'CS1.code'</span>,OPT.epsg.code,<span class="string">'CS2.code'</span>,OPT.wgs84.code);
</pre></div>
            </div>
            <div>
               <h2><a name="4">Define variable (define some data)</a></h2>
               <div><pre class="codeinput">   OPT.val                    = [1 2 3 4 5;6 7 8 9 10;11 12 nan 14 15]; <span class="comment">% use ncols as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)</span>
   OPT.varname                = <span class="string">'depth'</span>;       <span class="comment">% free to choose: will appear in netCDF tree</span>
   OPT.units                  = <span class="string">'m'</span>;           <span class="comment">% from UDunits package: http://www.unidata.ucar.edu/software/udunits/</span>
   OPT.long_name              = <span class="string">'bottom depth'</span>;<span class="comment">% free to choose: will appear in plots</span>
   OPT.standard_name          = <span class="string">'sea_floor_depth_below_geoid'</span>; <span class="comment">% or 'altitude'</span>
   OPT.val_type               = <span class="string">'single'</span>;      <span class="comment">% 'single' or 'double'</span>
   OPT.fillvalue              = nan;
</pre></div>
            </div>
            <div>
               <h2><a name="5">1.a Create netCDF file</a></h2>
               <div><pre class="codeinput">   ncfile = fullfile(fileparts(mfilename(<span class="string">'fullpath'</span>)),[mfilename,<span class="string">'.nc'</span>]);

   nc_create_empty (ncfile)
</pre></div>
            </div>
            <div>
               <h2><a name="6">1.b Add overall meta info</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#description-of-file-contents</pre><pre class="codeinput">   nc_attput(ncfile, nc_global, <span class="string">'title'</span>         , OPT.title);
   nc_attput(ncfile, nc_global, <span class="string">'institution'</span>   , OPT.institution);
   nc_attput(ncfile, nc_global, <span class="string">'source'</span>        , OPT.source);
   nc_attput(ncfile, nc_global, <span class="string">'history'</span>       , OPT.history);
   nc_attput(ncfile, nc_global, <span class="string">'references'</span>    , OPT.references);
   nc_attput(ncfile, nc_global, <span class="string">'email'</span>         , OPT.email);

   nc_attput(ncfile, nc_global, <span class="string">'comment'</span>       , OPT.comment);
   nc_attput(ncfile, nc_global, <span class="string">'version'</span>       , OPT.version);

   nc_attput(ncfile, nc_global, <span class="string">'Conventions'</span>   , <span class="string">'CF-1.4'</span>);
   nc_attput(ncfile, nc_global, <span class="string">'CF:featureType'</span>, <span class="string">'Grid'</span>);  <span class="comment">% https://cf-pcmdi.llnl.gov/trac/wiki/PointObservationConventions</span>

   nc_attput(ncfile, nc_global, <span class="string">'terms_for_use'</span> , OPT.acknowledge);
   nc_attput(ncfile, nc_global, <span class="string">'disclaimer'</span>    , OPT.disclaimer);
</pre></div>
            </div>
            <div>
               <h2><a name="7">2.a Create matrix span dimensions</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#dimensions</pre><pre class="codeinput">   nc_add_dimension(ncfile, <span class="string">'x'</span>, OPT.ncols); <span class="comment">% use this as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)</span>
   nc_add_dimension(ncfile, <span class="string">'y'</span>, OPT.nrows); <span class="comment">% use this as 2nd array dimension to get correct plot in ncBrowse (snctools swaps for us)</span>

   <span class="comment">% You might insert a vector 'col' that runs max(x):-dx:min(x) to have</span>
   <span class="comment">% the arcGIS ASCII file approach of having upper-left corner of</span>
   <span class="comment">% the data matrix at index (1,1) rather than the default of having the</span>
   <span class="comment">% lower-left corner of the data matrix  at index (1,1).</span>

<span class="comment">%  nc_add_dimension(ncfile, 'time', 1); % if you would like to include more instances of the same grid,</span>
                                        <span class="comment">% you can optionally use 'time' as a 3rd dimension. see</span>
                                        <span class="comment">% nc_cf_stationTimeSeries_write_tutorial for info on time.</span>
</pre></div>
            </div>
            <div>
               <h2><a name="8">3.a Create coordinate vectors: x and y</a></h2>
               <div><pre class="codeinput">   clear <span class="string">nc</span>;ifld = 1;
   nc(ifld).Name             = <span class="string">'x'</span>; <span class="comment">% dimension 'x' is here filled with variable 'x'</span>
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {<span class="string">'x'</span>};
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'x Rijksdriehoek'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'m'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'projection_x_coordinate'</span>); <span class="comment">% standard name</span>
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.x(:)) max(OPT.x(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'epsg'</span>);

   ifld = ifld + 1;
   nc(ifld).Name             = <span class="string">'y'</span>; <span class="comment">% dimension 'y' is here filled with variable 'y'</span>
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {<span class="string">'y'</span>};
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'y Rijksdriehoek'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'m'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'projection_y_coordinate'</span>); <span class="comment">% standard name</span>
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.y(:)) max(OPT.y(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'epsg'</span>);
</pre></div>
            </div>
            <div>
               <h2><a name="9">3.b Create coordinate variables: coordinate system: epsg</a></h2>
               <div><pre>    http://www.epsg-registry.org/</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name         = <span class="string">'epsg'</span>;
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct(<span class="string">'Name'</span>, <span class="keyword">...</span>
       {<span class="string">'name'</span>,<span class="keyword">...</span>
        <span class="string">'grid_mapping_name'</span>, <span class="keyword">...</span>
        <span class="string">'semi_major_axis'</span>, <span class="keyword">...</span>
        <span class="string">'semi_minor_axis'</span>, <span class="keyword">...</span>
        <span class="string">'inverse_flattening'</span>, <span class="keyword">...</span>
        <span class="string">'latitude_of_projection_origin'</span>, <span class="keyword">...</span>
        <span class="string">'longitude_of_projection_origin'</span>, <span class="keyword">...</span>
        <span class="string">'false_easting'</span>, <span class="keyword">...</span>
        <span class="string">'false_northing'</span>, <span class="keyword">...</span>
        <span class="string">'scale_factor_at_projection_origin'</span>, <span class="keyword">...</span>
        <span class="string">'comment'</span>}, <span class="keyword">...</span>
        <span class="string">'Value'</span>, <span class="keyword">...</span>
        {log.CS1.name,<span class="keyword">...</span>
         log.proj_conv1.method.name,     <span class="keyword">...</span>
         log.CS1.ellips.semi_major_axis, <span class="keyword">...</span>
         log.CS1.ellips.semi_minor_axis, <span class="keyword">...</span>
         log.CS1.ellips.inv_flattening,  <span class="keyword">...</span>
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,<span class="string">'Latitude of natural origin'</span>    )),<span class="keyword">...</span>
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,<span class="string">'Longitude of natural origin'</span>   )),<span class="keyword">...</span>
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,<span class="string">'False easting'</span>                 )),<span class="keyword">...</span>
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,<span class="string">'False northing'</span>                )),<span class="keyword">...</span>
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,<span class="string">'Scale factor at natural origin'</span>)),<span class="keyword">...</span>
        <span class="string">'value is equal to EPSG code'</span>});
</pre></div>
            </div>
            <div>
               <h2><a name="10">3.c Create coordinate variables: longitude</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#longitude-coordinate</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name             = <span class="string">'lon'</span>;
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {<span class="string">'x'</span>,<span class="string">'y'</span>};
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'longitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'degrees_east'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'longitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.lon(:)) max(OPT.lon(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'lat lon'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'wgs84'</span>);
</pre></div>
            </div>
            <div>
               <h2><a name="11">3.d Create coordinate variables: latitude</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#latitude-coordinate</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name             = <span class="string">'lat'</span>;
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {<span class="string">'x'</span>,<span class="string">'y'</span>};
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'latitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'degrees_north'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'latitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.lat(:)) max(OPT.lat(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'lat lon'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'wgs84'</span>);
</pre></div>
            </div>
            <div>
               <h2><a name="12">3.e Create coordinate variables: coordinate system: WGS84 default</a></h2>
               <div><pre>    global ellispes: WGS 84, ED 50, INT 1924, ETRS 89 and the upcoming ETRS update etc.
    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#appendix-grid-mappings</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name         = <span class="string">'wgs84'</span>; <span class="comment">% preferred</span>
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct(<span class="string">'Name'</span>, <span class="keyword">...</span>
    {<span class="string">'name'</span>,<span class="keyword">...</span>
     <span class="string">'semi_major_axis'</span>, <span class="keyword">...</span>
     <span class="string">'semi_minor_axis'</span>, <span class="keyword">...</span>
     <span class="string">'inverse_flattening'</span>, <span class="keyword">...</span>
     <span class="string">'comment'</span>}, <span class="keyword">...</span>
     <span class="string">'Value'</span>, <span class="keyword">...</span>
     {log.CS2.name,<span class="keyword">...</span>
      log.CS2.ellips.semi_major_axis, <span class="keyword">...</span>
      log.CS2.ellips.semi_minor_axis, <span class="keyword">...</span>
      log.CS2.ellips.inv_flattening,  <span class="keyword">...</span>
     <span class="string">'value is equal to EPSG code'</span>});
</pre></div>
            </div>
            <div>
               <h2><a name="13">4   Create dependent variable</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#variables
    Parameters with standard names:
    http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name             = OPT.varname;
   nc(ifld).Nctype           = nc_type(OPT.val_type);
   nc(ifld).Dimension        = {<span class="string">'x'</span>,<span class="string">'y'</span>}; <span class="comment">% {'time','x','y'};</span>
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, OPT.long_name    );
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, OPT.units        );
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'_FillValue'</span>     ,<span class="string">'Value'</span>, OPT.fillvalue    );
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.val(:)) max(OPT.val(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'lat lon'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'epsg'</span>);
   <span class="keyword">if</span> ~isempty(OPT.standard_name)
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, OPT.standard_name);
   <span class="keyword">end</span>
</pre></div>
            </div>
            <div>
               <h2><a name="14">5.a Create all variables with attributes</a></h2>
               <div><pre class="codeinput">   <span class="keyword">for</span> ifld=1:length(nc)
      nc_addvar(ncfile, nc(ifld));
   <span class="keyword">end</span>
</pre></div>
            </div>
            <div>
               <h2><a name="15">5.b Fill all variables</a></h2>
               <div><pre class="codeinput">   nc_varput(ncfile, <span class="string">'x'</span>            , OPT.x         );
   nc_varput(ncfile, <span class="string">'y'</span>            , OPT.y         );
   nc_varput(ncfile, <span class="string">'epsg'</span>         , OPT.epsg.code );
   nc_varput(ncfile, <span class="string">'lon'</span>          , OPT.lon       );
   nc_varput(ncfile, <span class="string">'lat'</span>          , OPT.lat       );
   nc_varput(ncfile, <span class="string">'wgs84'</span>        , OPT.wgs84.code);
   nc_varput(ncfile, OPT.varname    , OPT.val       );
</pre></div>
            </div>
            <div>
               <h2><a name="16">6   Check file summary</a></h2>
               <div><pre class="codeinput">   nc_dump(ncfile);
</pre><pre class="codeoutput">netCDF e:\Temp\tp805a2653_9ab1_4819_98b1_2e7cf33110a0\nc_cf_grid_write_x_y_orthogonal_tutorial.nc { 

dimensions:
	x = 3 ;
	y = 5 ;


variables:
	// Preference 'PRESERVE_FVD':  false,
	// dimensions consistent with ncBrowse, not with native MATLAB netcdf package.
	single x(x), shape = [3]
		x:long_name = "x Rijksdriehoek" 
		x:units = "m" 
		x:standard_name = "projection_x_coordinate" 
		x:actual_range = 400000 600000 
		x:grid_mapping = "epsg" 
	single y(y), shape = [5]
		y:long_name = "y Rijksdriehoek" 
		y:units = "m" 
		y:standard_name = "projection_y_coordinate" 
		y:actual_range = 5.5e+006 5.9e+006 
		y:grid_mapping = "epsg" 
	int32 epsg([]), shape = [1]
		epsg:name = "WGS 84 / UTM zone 31N" 
		epsg:grid_mapping_name = "Transverse Mercator" 
		epsg:semi_major_axis = 6.37814e+006 
		epsg:semi_minor_axis = 6.35675e+006 
		epsg:inverse_flattening = 298.257 
		epsg:latitude_of_projection_origin = 0 
		epsg:longitude_of_projection_origin = 3 
		epsg:false_easting = 500000 
		epsg:false_northing = 0 
		epsg:scale_factor_at_projection_origin = 0.9996 
		epsg:comment = "value is equal to EPSG code" 
	single lon(x,y), shape = [3 5]
		lon:long_name = "longitude" 
		lon:units = "degrees_east" 
		lon:standard_name = "longitude" 
		lon:actual_range = 1.50155 4.49845 
		lon:coordinates = "lat lon" 
		lon:grid_mapping = "wgs84" 
	single lat(x,y), shape = [3 5]
		lat:long_name = "latitude" 
		lat:units = "degrees_north" 
		lat:standard_name = "latitude" 
		lat:actual_range = 49.6443 53.2493 
		lat:coordinates = "lat lon" 
		lat:grid_mapping = "wgs84" 
	int32 wgs84([]), shape = [1]
		wgs84:name = "WGS 84" 
		wgs84:semi_major_axis = 6.37814e+006 
		wgs84:semi_minor_axis = 6.35675e+006 
		wgs84:inverse_flattening = 298.257 
		wgs84:comment = "value is equal to EPSG code" 
	single depth(x,y), shape = [3 5]
		depth:long_name = "bottom depth" 
		depth:units = "m" 
		depth:_FillValue = NaN 
		depth:actual_range = 1 15 
		depth:coordinates = "lat lon" 
		depth:grid_mapping = "epsg" 
		depth:standard_name = "sea_floor_depth_below_geoid" 


//global attributes:
		:title = "" 
		:institution = "" 
		:source = "" 
		:history = "tranformation to netCDF: $HeadURL: https://repos.deltares.nl/repos/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_orthogonal_tutorial.m $" 
		:references = "" 
		:email = "" 
		:comment = "" 
		:version = "" 
		:Conventions = "CF-1.4" 
		:CF:featureType = "Grid" 
		:terms_for_use = "These data can be used freely for research purposes provided that the following source is acknowledged: " 
		:disclaimer = "This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE." 
}
</pre></div>
            </div>
            <div>
               <h2><a name="17">7.a Load the data: using the variable names from nc_dump</a></h2>
               <div><pre class="codeinput">   Da.dep   = nc_varget(ncfile,<span class="string">'depth'</span>);
   Da.lat   = nc_varget(ncfile,<span class="string">'lon'</span>);
   Da.lon   = nc_varget(ncfile,<span class="string">'lat'</span>)
</pre><pre class="codeoutput">
Da = 

    dep: [3x5 double]
    lat: [3x5 single]
    lon: [3x5 single]

</pre></div>
            </div>
            <div>
               <h2><a name="18">7.b Load the data: using standard_names and coordinate attribute</a></h2>
               <div><pre class="codeinput">   depname  = nc_varfind(ncfile,<span class="string">'attributename'</span>, <span class="string">'standard_name'</span>, <span class="string">'attributevalue'</span>, <span class="string">'sea_floor_depth_below_geoid'</span>)
   Db.z     = nc_varget(ncfile,depname);

   coords   = nc_attget(ncfile,depname,<span class="string">'coordinates'</span>);
  [ax1,coords] = strtok(coords); ax2 = strtok(coords);
   <span class="keyword">if</span> strcmpi(nc_attget(ncfile,ax1,<span class="string">'standard_name'</span>),<span class="string">'latitude'</span>)
   Db.lat   = nc_varget(ncfile,ax1);
   Db.lon   = nc_varget(ncfile,ax2)
   <span class="keyword">else</span>
   Db.lat   = nc_varget(ncfile,ax2);
   Db.lon   = nc_varget(ncfile,ax1)
   <span class="keyword">end</span>
</pre><pre class="codeoutput">
depname =

depth


Db = 

      z: [3x5 double]
    lat: [3x5 single]
    lon: [3x5 single]

</pre></div>
            </div>
            <div>
               <h2><a name="19">7.c Load the data: using a dedicated function developed for grids</a></h2>
               <div><pre class="codeinput">   [Dc,Mc] = nc_cf_grid(ncfile,OPT.varname)
</pre><pre class="codeoutput">
Dc = 

      lon: [3x5 single]
      lat: [3x5 single]
    depth: [3x5 double]


Mc = 

      lon: [1x1 struct]
      lat: [1x1 struct]
    depth: [1x1 struct]

</pre><img vspace="5" hspace="5" src="nc_cf_grid_write_x_y_orthogonal_tutorial_01.png" relsrc="nc_cf_grid_write_x_y_orthogonal_tutorial_01.png"> </div>
            </div>
         </div>
         <p class="footer"><br>
            this tutorial is based on: <a class="matlabhref" href="matlab:edit('nc_cf_grid_write_x_y_orthogonal_tutorial');" browserhref="http://crucible.delftgeosystems.nl/browse/~raw,r=2703/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_orthogonal_tutorial.m">nc_cf_grid_write_x_y_orthogonal_tutorial.m (revision: 2703)</a><br>
Published with MATLAB&reg; 7.10<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Create netCDF-CF of orthogonal x-y grid
%
%  example of how to make a netCDF file with CF conventions of a 
%  variable that is defined on a grid that is orthogonal
%  in a x-y coordinate system. In this special case 
%  the dimensions coincide with the x-y coordinate axes.
%  The associated lat-lon coordinate matrices are curvi-linear.
%
%  This case is described in:
%  http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
%  as "Horizontal Coordinate Reference Systems, Grid Mappings, and Projections".
%
%  An example of an orthogonal x,y grid is for instance
%  a data product defined on an otrhogonal grid in a certain 
%  local geograhic projection by programs like arcGIS. For each
%  vertex in this grid a the lat,lon values need to be calculated
%  to project it on the globe (e.g. Google Earth).
%
%    ^ latitude (degrees_north)           ^ y(m)
%    |         x                          |
%    | ncols /   \                        |        ncols
%    |     /  /\   \              coordinate	  +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+
%    |   /   /15\    \          transformation
%    |  x  /10   \     \       <==============>	 +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+
%    |    <5     14\     \                |      |05 10 15|  +
%    |     \   9    \      \              |      |        |  |
%    |      \4       \      |             |      |04 09 14|  |
%    |       \        \     |             |      |        |  |
%    |        )3  8  xx)    | nrows       |      |03 08 xx|  | nrows
%    |       /        /     |             |      |        |  |
%    |      /2       /      |             |      |02 07 12|  | 
%    |     /   7    /      /              |      |        |  |
%    |    <1     12/     /                |      |01 06 11|  +
%    |     \6    /     /                  |      +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+
%    |       \11/    /                    |
%    |        \/   x                      |
%    |                                    |
%    +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH> longitude   +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH> x
%                        (degrees_east)                          (m)
%
% Note that ncBrowse does not contain plot support for 
% curvi-linear grids, so ncBrowse will display the same 
% rectangular plot as for the netCDF file created by
% NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL, albeit with
% different axes annotations (col/row instead of lat/lon).
%
%See also: SNCTOOLS, NC_CF_GRID, NC_CF_GRID_WRITE,
%          NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL, 
%          NC_CF_GRID_WRITE_LAT_LON_CURVILINEAR_TUTORIAL, 
%          NC_CF_GRID_WRITE_X_Y_CURVILINEAR_TUTORIAL,
%          NC_CF_STATIONTIMESERIES
%
% This tool is part of <a href="http://www.OpenEarth.eu">OpenEarthTools</a> under the <a href="http://www.gnu.org/licenses/gpl.html">GPL</a> license.

%% Define meta-info: global: x,y sticks > lat,lon matrices

   OPT.title                  = '';
   OPT.institution            = '';
   OPT.source                 = '';
   OPT.history                = ['tranformation to netCDF: $HeadURL: https://repos.deltares.nl/repos/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_orthogonal_tutorial.m $'];
   OPT.references             = '';
   OPT.email                  = '';
   OPT.comment                = '';
   OPT.version                = '';
   OPT.acknowledge            =['These data can be used freely for research purposes provided that the following source is acknowledged: ',OPT.institution];
   OPT.disclaimer             = 'This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.';
   
%% Define dimensions/coordinates

   OPT.x                      = [400 500 600].*1e3;
   OPT.y                      = [5500:100:5900].*1e3;

  [x,y]                       = ndgrid(OPT.x,OPT.y);

   OPT.ncols                  = length(OPT.x);
   OPT.nrows                  = length(OPT.y);
   OPT.lat_type               = 'single'; % 'single', 'double' for high-resolution data (eps 1m)
   OPT.lon_type               = 'single'; % 'single', 'double' for high-resolution data (eps 1m)

   OPT.epsg.code              = 32631; % epsg code of local projection
   OPT.wgs84.code             = 4326;  % epsg code of global grid
   % http://www.epsg-registry.org/
   % in the case of a grid defined in a local x-y 
   % projection, the properties of the grid in a WGS84
   % lat,lon system do not have to be specified here, but 
   % can be retrieved from the log of the coordinate 
   % transformation carried out by convertCoordinates.
   % get (lat,lon) associated with each vertex (x,y), note order [OPT.lon,OPT.lat ...

  [OPT.lon,OPT.lat,log]       = convertCoordinates(x,y,'CS1.code',OPT.epsg.code,'CS2.code',OPT.wgs84.code);

  %% Define variable (define some data)

   OPT.val                    = [1 2 3 4 5;6 7 8 9 10;11 12 nan 14 15]; % use ncols as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)
   OPT.varname                = 'depth';       % free to choose: will appear in netCDF tree
   OPT.units                  = 'm';           % from UDunits package: http://www.unidata.ucar.edu/software/udunits/
   OPT.long_name              = 'bottom depth';% free to choose: will appear in plots
   OPT.standard_name          = 'sea_floor_depth_below_geoid'; % or 'altitude'
   OPT.val_type               = 'single';      % 'single' or 'double'
   OPT.fillvalue              = nan;
   
%% 1.a Create netCDF file

   ncfile = fullfile(fileparts(mfilename('fullpath')),[mfilename,'.nc']);

   nc_create_empty (ncfile)

%% 1.b Add overall meta info
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#description-of-file-contents
   
   nc_attput(ncfile, nc_global, 'title'         , OPT.title);
   nc_attput(ncfile, nc_global, 'institution'   , OPT.institution);
   nc_attput(ncfile, nc_global, 'source'        , OPT.source);
   nc_attput(ncfile, nc_global, 'history'       , OPT.history);
   nc_attput(ncfile, nc_global, 'references'    , OPT.references);
   nc_attput(ncfile, nc_global, 'email'         , OPT.email);

   nc_attput(ncfile, nc_global, 'comment'       , OPT.comment);
   nc_attput(ncfile, nc_global, 'version'       , OPT.version);

   nc_attput(ncfile, nc_global, 'Conventions'   , 'CF-1.4');
   nc_attput(ncfile, nc_global, 'CF:featureType', 'Grid');  % https://cf-pcmdi.llnl.gov/trac/wiki/PointObservationConventions

   nc_attput(ncfile, nc_global, 'terms_for_use' , OPT.acknowledge);
   nc_attput(ncfile, nc_global, 'disclaimer'    , OPT.disclaimer);
      
%% 2.a Create matrix span dimensions
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#dimensions   
   
   nc_add_dimension(ncfile, 'x', OPT.ncols); % use this as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)
   nc_add_dimension(ncfile, 'y', OPT.nrows); % use this as 2nd array dimension to get correct plot in ncBrowse (snctools swaps for us)

   % You might insert a vector 'col' that runs max(x):-dx:min(x) to have
   % the arcGIS ASCII file approach of having upper-left corner of 
   % the data matrix at index (1,1) rather than the default of having the 
   % lower-left corner of the data matrix  at index (1,1).

%  nc_add_dimension(ncfile, 'time', 1); % if you would like to include more instances of the same grid, 
                                        % you can optionally use 'time' as a 3rd dimension. see 
                                        % nc_cf_stationTimeSeries_write_tutorial for info on time.          

%% 3.a Create coordinate vectors: x and y

   clear nc;ifld = 1;
   nc(ifld).Name             = 'x'; % dimension 'x' is here filled with variable 'x'
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {'x'};
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'x Rijksdriehoek');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'm');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'projection_x_coordinate'); % standard name
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.x(:)) max(OPT.x(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'epsg');

   ifld = ifld + 1;
   nc(ifld).Name             = 'y'; % dimension 'y' is here filled with variable 'y'
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {'y'};
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'y Rijksdriehoek');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'm');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'projection_y_coordinate'); % standard name
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.y(:)) max(OPT.y(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'epsg');

%% 3.b Create coordinate variables: coordinate system: epsg
%      http://www.epsg-registry.org/
   
   ifld = ifld + 1;
   nc(ifld).Name         = 'epsg';
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct('Name', ...
       {'name',...
        'grid_mapping_name', ...
        'semi_major_axis', ...
        'semi_minor_axis', ...
        'inverse_flattening', ...
        'latitude_of_projection_origin', ...
        'longitude_of_projection_origin', ...
        'false_easting', ...
        'false_northing', ...
        'scale_factor_at_projection_origin', ...
        'comment'}, ...
        'Value', ...
        {log.CS1.name,...
         log.proj_conv1.method.name,     ...
         log.CS1.ellips.semi_major_axis, ...
         log.CS1.ellips.semi_minor_axis, ...
         log.CS1.ellips.inv_flattening,  ...
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,'Latitude of natural origin'    )),...
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,'Longitude of natural origin'   )),...
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,'False easting'                 )),...
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,'False northing'                )),...
         log.proj_conv1.param.value(strcmp(log.proj_conv1.param.name,'Scale factor at natural origin')),...
        'value is equal to EPSG code'});

%% 3.c Create coordinate variables: longitude
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#longitude-coordinate

   ifld = ifld + 1;
   nc(ifld).Name             = 'lon';
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {'x','y'};
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'longitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'degrees_east');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'longitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.lon(:)) max(OPT.lon(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'wgs84');

%% 3.d Create coordinate variables: latitude
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#latitude-coordinate
   
   ifld = ifld + 1;
   nc(ifld).Name             = 'lat';
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {'x','y'};
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'latitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'degrees_north');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'latitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.lat(:)) max(OPT.lat(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'wgs84');

%% 3.e Create coordinate variables: coordinate system: WGS84 default
%      global ellispes: WGS 84, ED 50, INT 1924, ETRS 89 and the upcoming ETRS update etc.
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#appendix-grid-mappings
   
   ifld = ifld + 1;
   nc(ifld).Name         = 'wgs84'; % preferred
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct('Name', ...
    {'name',...
     'semi_major_axis', ...
     'semi_minor_axis', ...
     'inverse_flattening', ...
     'comment'}, ...
     'Value', ...
     {log.CS2.name,...
      log.CS2.ellips.semi_major_axis, ...
      log.CS2.ellips.semi_minor_axis, ...
      log.CS2.ellips.inv_flattening,  ...
     'value is equal to EPSG code'});

%% 4   Create dependent variable
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#variables
%      Parameters with standard names:
%      http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/

   ifld = ifld + 1;
   nc(ifld).Name             = OPT.varname;
   nc(ifld).Nctype           = nc_type(OPT.val_type);
   nc(ifld).Dimension        = {'x','y'}; % {'time','x','y'};
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', OPT.long_name    );
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', OPT.units        );
   nc(ifld).Attribute(end+1) = struct('Name', '_FillValue'     ,'Value', OPT.fillvalue    );
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.val(:)) max(OPT.val(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'epsg');
   if ~isempty(OPT.standard_name)
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', OPT.standard_name);
   end
      
%% 5.a Create all variables with attributes
   
   for ifld=1:length(nc)
      nc_addvar(ncfile, nc(ifld));   
   end
      
%% 5.b Fill all variables

   nc_varput(ncfile, 'x'            , OPT.x         );
   nc_varput(ncfile, 'y'            , OPT.y         );
   nc_varput(ncfile, 'epsg'         , OPT.epsg.code );
   nc_varput(ncfile, 'lon'          , OPT.lon       );
   nc_varput(ncfile, 'lat'          , OPT.lat       );
   nc_varput(ncfile, 'wgs84'        , OPT.wgs84.code);
   nc_varput(ncfile, OPT.varname    , OPT.val       );
      
%% 6   Check file summary
   
   nc_dump(ncfile);

%% 7.a Load the data: using the variable names from nc_dump

   Da.dep   = nc_varget(ncfile,'depth');
   Da.lat   = nc_varget(ncfile,'lon');
   Da.lon   = nc_varget(ncfile,'lat')

%% 7.b Load the data: using standard_names and coordinate attribute

   depname  = nc_varfind(ncfile,'attributename', 'standard_name', 'attributevalue', 'sea_floor_depth_below_geoid')
   Db.z     = nc_varget(ncfile,depname);

   coords   = nc_attget(ncfile,depname,'coordinates');
  [ax1,coords] = strtok(coords); ax2 = strtok(coords);
   if strcmpi(nc_attget(ncfile,ax1,'standard_name'),'latitude')
   Db.lat   = nc_varget(ncfile,ax1);
   Db.lon   = nc_varget(ncfile,ax2)
   else
   Db.lat   = nc_varget(ncfile,ax2);
   Db.lon   = nc_varget(ncfile,ax1)
   end

%% 7.c Load the data: using a dedicated function developed for grids

   [Dc,Mc] = nc_cf_grid(ncfile,OPT.varname)

##### SOURCE END #####
-->
   </body>
</html>