
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>nc_cf_grid_write_x_y_curvilinear_tutorial</title>
      <meta name="generator" content="MATLAB 7.10">
      <meta name="date" content="2010-06-22">
      <meta name="m-file" content="nc_cf_grid_write_x_y_curvilinear_tutorial">
      <link type="text/css" href="script/css/jquery-ui-1.7.2.custom.css" rel="stylesheet">
      <link type="text/css" href="script/css/jquery.collapsible.css" rel="stylesheet"><script type="text/javascript" src="script/js/jquery-1.3.2.min.js"></script><script type="text/javascript" src="script/js/jquery-ui-1.7.2.custom.min.js"></script><script type="text/javascript" src="script/js/matlab2collapsible.js"></script><script type="text/javascript" src="script/js/jquery.collapsible.js"></script><script type="text/javascript" src="script/js/matlabhelp.js"></script><script src="http://www.google.com/jsapi?key=ABQIAAAA9KO06BPsmsvzw4PogoawhRRxYg1slSMvxuda9W0Kolc-SbeLlhQGHwE9W-XlCfe8WtZh74R56zOChQ"></script><script type="text/javascript" src="script/js/googleEarthApi.js"></script><script type="text/javascript">
    $(document).ready(function ()
      {
        // Copy content
	copycontent();

	// validate href of links to matlab tutorials
	matlabpreparehelprefs();

  	// Accordion
  	collapsible($(".collapsible"));
	
	// googleearth($(".geapi"));
	currentGeApiDiv = $(".geapi");	
      });
    </script><link type="text/css" href="script/css/matlabcode.css" rel="stylesheet">
   </head>
   <body LINK="#48339F" VLINK="#48339F" ALINK="#48339F">
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Create netCDF-CF of curvilinear x-y grid</a></li>
               <li><a href="#2">Define meta-info: global: x,y matrices &lt;&gt; lat,lon matrices</a></li>
               <li><a href="#3">Define dimensions/coordinates</a></li>
               <li><a href="#4">Define variable (define some data)</a></li>
               <li><a href="#5">1.a Create netCDF file</a></li>
               <li><a href="#6">1.b Add overall meta info</a></li>
               <li><a href="#7">2   Create matrix span dimensions</a></li>
               <li><a href="#8">3.a Create coordinate variables: x and y</a></li>
               <li><a href="#9">3.b Create coordinate variables: coordinate system: epsg</a></li>
               <li><a href="#10">3.c Create coordinate variables: longitude</a></li>
               <li><a href="#11">3.d Create coordinate variables: latitude</a></li>
               <li><a href="#12">3.e Create coordinate variables: coordinate system: WGS84 default</a></li>
               <li><a href="#13">4   Create dependent variable</a></li>
               <li><a href="#14">5.a Create all variables with attributes</a></li>
               <li><a href="#15">5.b Fill all variables</a></li>
               <li><a href="#16">6   Check file summary</a></li>
               <li><a href="#17">7.a Load the data: using the variable names from nc_dump</a></li>
               <li><a href="#18">7.b Load the data: using standard_names and coordinate attribute</a></li>
               <li><a href="#19">7.c Load the data: using a dedicated function developed for grids</a></li>
            </ul>
         </div>
         <div class="collapsible">
            <div>
               <h2><a name="1">Create netCDF-CF of curvilinear x-y grid</a></h2>
               <div><pre>example of how to make a netCDF file with CF conventions of a
variable that is defined on a grid that is curvilinear
in a x-y coordinate system. In this case
the dimensions (m,n) do not coincide with the coordinate axes.</pre><pre>This case is partly described in:
http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
as "Horizontal Coordinate Reference Systems, Grid Mappings, and Projections".</pre><pre>An example of a curvi-linear x,y grid is for instance
the grid of a regional general circulation model such
as Delft3D, ROMS or POM that has been ddesigned to follow
coastal feartures smoothly.</pre><pre>  ^ latitude (degrees_north)           ^ y(m)
  |         x                          |             x
  | ncols /   \                        |     ncols /   \
  |     /  /\   \              coordinate        /  /\   \
  |   /   /15\    \          transformation    /   /15\    \
  |  x  /10   \     \       &lt;==============&gt;  x  /10   \     \
  |    &lt;5     14\     \                |        &lt;5     14\     \
  |     \   9    \      \              |         \   9    \      \
  |      \4       \      |             |          \4       \      |
  |       \        \     |             |           \        \     |
  |        )3  8  xx)    | nrows       |            )3  8  xx)    |
  |       /        /     |             |           /        /     |
  |      /2       /      |             |          /2       /      |
  |     /   7    /      /              |         /   7    /      /
  |    &lt;1     12/     /                |        &lt;1     12/     /
  |     \6    /     /                  |         \6    /     /
  |       \11/    /                    |          \11/    /
  |        \/   x                      |           \/   x
  |                                    |
  +----------------------&gt; longitude   +----------------------&gt; x
                      (degrees_east)                          (m)</pre><p>Note that ncBrowse does not contain plot support for curvi-linear grids, so ncBrowse will display the same rectangular plot
                     as for the netCDF file created by NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL, albeit with different axes annotations (col/row
                     instead of lat/lon).
                  </p><pre class="codeinput"><span class="comment">%See also: SNCTOOLS, NC_CF_GRID, NC_CF_GRID_WRITE,</span>
<span class="comment">%          NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL,</span>
<span class="comment">%          NC_CF_GRID_WRITE_LAT_LON_CURVILINEAR_TUTORIAL,</span>
<span class="comment">%          NC_CF_GRID_WRITE_X_Y_ORTHOGONAL_TUTORIAL,</span>
<span class="comment">%          NC_CF_STATIONTIMESERIES</span>
<span class="comment">%</span>
<span class="comment">% This tool is part of &lt;a href="http://www.OpenEarth.eu"&gt;OpenEarthTools&lt;/a&gt; under the &lt;a href="http://www.gnu.org/licenses/gpl.html"&gt;GPL&lt;/a&gt; license.</span>
</pre></div>
            </div>
            <div>
               <h2><a name="2">Define meta-info: global: x,y matrices &lt;&gt; lat,lon matrices</a></h2>
               <div><pre class="codeinput">   OPT.title                  = <span class="string">''</span>;
   OPT.institution            = <span class="string">''</span>;
   OPT.source                 = <span class="string">''</span>;
   OPT.history                = [<span class="string">'tranformation to netCDF: $HeadURL: https://repos.deltares.nl/repos/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_curvilinear_tutorial.m $'</span>];
   OPT.references             = <span class="string">''</span>;
   OPT.email                  = <span class="string">''</span>;
   OPT.comment                = <span class="string">''</span>;
   OPT.version                = <span class="string">''</span>;
   OPT.acknowledge            =[<span class="string">'These data can be used freely for research purposes provided that the following source is acknowledged: '</span>,OPT.institution];
   OPT.disclaimer             = <span class="string">'This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'</span>;
</pre></div>
            </div>
            <div>
               <h2><a name="3">Define dimensions/coordinates</a></h2>
               <div><pre>exactly same grid same nc_cf_grid_write_lat_lon_curvilinear_tutorial.m</pre><pre class="codeinput">   lon1                       = [2 4 6];
   lat1                       = [50 51 52 53 54];
  [lon2,lat2]                 = ndgrid(lon1,lat1);
   ang                        = [-15 0 15 30 45;-15 0 15 30 45;-15 0 15 30 45];
   OPT.lat                    = lat2 + sind(ang).*lon2./2;
   OPT.lon                    = lon2 + cosd(ang).*lon2./2; clear <span class="string">lon1</span> <span class="string">lon2</span> <span class="string">lat1</span> <span class="string">lat2</span>

   OPT.ncols                  = size(OPT.lon,1);
   OPT.nrows                  = size(OPT.lat,2);
   OPT.lat_type               = <span class="string">'single'</span>; <span class="comment">% 'single', 'double' for high-resolution data (eps 1m)</span>
   OPT.lon_type               = <span class="string">'single'</span>; <span class="comment">% 'single', 'double' for high-resolution data (eps 1m)</span>

   OPT.epsg.code              = 32631; <span class="comment">% epsg code of local projection</span>
   OPT.wgs84.code             = 4326;  <span class="comment">% epsg code of global grid</span>
   <span class="comment">% http://www.epsg-registry.org/</span>
   <span class="comment">% in the case of a grid defined in a local x-y</span>
   <span class="comment">% projection, the properties of the grid in a WGS84</span>
   <span class="comment">% lat,lon system do not have to be specified here, but</span>
   <span class="comment">% can be retrieved from the log of the coordinate</span>
   <span class="comment">% transformation carried out by convertCoordinates:</span>
   <span class="comment">% get (x,y) associated with each vertex (lat,lon), note order (OPT.lon,OPT.lat ...</span>

  [OPT.x,OPT.y,log]           = convertCoordinates(OPT.lon,OPT.lat,<span class="string">'CS1.code'</span>,OPT.wgs84.code,<span class="string">'CS2.code'</span>,OPT.epsg.code);
</pre></div>
            </div>
            <div>
               <h2><a name="4">Define variable (define some data)</a></h2>
               <div><pre class="codeinput">   OPT.val                    = [1 2 3 4 5;6 7 8 9 10;11 12 nan 14 15]; <span class="comment">% use ncols as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)</span>
   OPT.varname                = <span class="string">'depth'</span>;       <span class="comment">% free to choose: will appear in netCDF tree</span>
   OPT.units                  = <span class="string">'m'</span>;           <span class="comment">% from UDunits package: http://www.unidata.ucar.edu/software/udunits/</span>
   OPT.long_name              = <span class="string">'bottom depth'</span>;<span class="comment">% free to choose: will appear in plots</span>
   OPT.standard_name          = <span class="string">'sea_floor_depth_below_geoid'</span>; <span class="comment">% or 'altitude'</span>
   OPT.val_type               = <span class="string">'single'</span>;      <span class="comment">% 'single' or 'double'</span>
   OPT.fillvalue              = nan;
</pre></div>
            </div>
            <div>
               <h2><a name="5">1.a Create netCDF file</a></h2>
               <div><pre class="codeinput">   ncfile = fullfile(fileparts(mfilename(<span class="string">'fullpath'</span>)),[mfilename,<span class="string">'.nc'</span>]);

   nc_create_empty (ncfile)
</pre></div>
            </div>
            <div>
               <h2><a name="6">1.b Add overall meta info</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#description-of-file-contents</pre><pre class="codeinput">   nc_attput(ncfile, nc_global, <span class="string">'title'</span>         , OPT.title);
   nc_attput(ncfile, nc_global, <span class="string">'institution'</span>   , OPT.institution);
   nc_attput(ncfile, nc_global, <span class="string">'source'</span>        , OPT.source);
   nc_attput(ncfile, nc_global, <span class="string">'history'</span>       , OPT.history);
   nc_attput(ncfile, nc_global, <span class="string">'references'</span>    , OPT.references);
   nc_attput(ncfile, nc_global, <span class="string">'email'</span>         , OPT.email);

   nc_attput(ncfile, nc_global, <span class="string">'comment'</span>       , OPT.comment);
   nc_attput(ncfile, nc_global, <span class="string">'version'</span>       , OPT.version);

   nc_attput(ncfile, nc_global, <span class="string">'Conventions'</span>   , <span class="string">'CF-1.4'</span>);
   nc_attput(ncfile, nc_global, <span class="string">'CF:featureType'</span>, <span class="string">'Grid'</span>);  <span class="comment">% https://cf-pcmdi.llnl.gov/trac/wiki/PointObservationConventions</span>

   nc_attput(ncfile, nc_global, <span class="string">'terms_for_use'</span> , OPT.acknowledge);
   nc_attput(ncfile, nc_global, <span class="string">'disclaimer'</span>    , OPT.disclaimer);
</pre></div>
            </div>
            <div>
               <h2><a name="7">2   Create matrix span dimensions</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#dimensions</pre><pre class="codeinput">   nc_add_dimension(ncfile, <span class="string">'col'</span>, OPT.ncols); <span class="comment">% !!! use this as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)</span>
   nc_add_dimension(ncfile, <span class="string">'row'</span>, OPT.nrows); <span class="comment">% !!! use this as 2nd array dimension to get correct plot in ncBrowse (snctools swaps for us)</span>

   <span class="comment">% You might insert a vector 'col' that runs max(x):-dx:min(x) to have</span>
   <span class="comment">% the arcGIS ASCII file approach of having upper-left corner of</span>
   <span class="comment">% the data matrix at index (1,1) rather than the default of having the</span>
   <span class="comment">% lower-left corner of the data matrix  at index (1,1).</span>

<span class="comment">%  nc_add_dimension(ncfile, 'time', 1); % if you would like to include more instances of the same grid,</span>
                                        <span class="comment">% you can optionally use 'time' as a 3rd dimension. see</span>
                                        <span class="comment">% nc_cf_stationTimeSeries_write_tutorial for info on time.</span>
</pre></div>
            </div>
            <div>
               <h2><a name="8">3.a Create coordinate variables: x and y</a></h2>
               <div><pre class="codeinput">   clear <span class="string">nc</span>;ifld = 1;
   nc(ifld).Name             = <span class="string">'x'</span>;
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {<span class="string">'col'</span>,<span class="string">'row'</span>}; <span class="comment">% !!!</span>
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'x Rijksdriehoek'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'m'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'projection_x_coordinate'</span>); <span class="comment">% standard name</span>
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.x(:)) max(OPT.x(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'lat lon'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'epsg'</span>);

   ifld = ifld + 1;
   nc(ifld).Name             = <span class="string">'y'</span>;
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {<span class="string">'col'</span>,<span class="string">'row'</span>}; <span class="comment">% !!!</span>
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'y Rijksdriehoek'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'m'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'projection_y_coordinate'</span>); <span class="comment">% standard name</span>
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.y(:)) max(OPT.y(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'lat lon'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'epsg'</span>);
</pre></div>
            </div>
            <div>
               <h2><a name="9">3.b Create coordinate variables: coordinate system: epsg</a></h2>
               <div><pre>    http://www.epsg-registry.org/</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name         = <span class="string">'epsg'</span>;
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct(<span class="string">'Name'</span>, <span class="keyword">...</span>
       {<span class="string">'name'</span>,<span class="keyword">...</span>
        <span class="string">'grid_mapping_name'</span>, <span class="keyword">...</span>
        <span class="string">'semi_major_axis'</span>, <span class="keyword">...</span>
        <span class="string">'semi_minor_axis'</span>, <span class="keyword">...</span>
        <span class="string">'inverse_flattening'</span>, <span class="keyword">...</span>
        <span class="string">'latitude_of_projection_origin'</span>, <span class="keyword">...</span>
        <span class="string">'longitude_of_projection_origin'</span>, <span class="keyword">...</span>
        <span class="string">'false_easting'</span>, <span class="keyword">...</span>
        <span class="string">'false_northing'</span>, <span class="keyword">...</span>
        <span class="string">'scale_factor_at_projection_origin'</span>, <span class="keyword">...</span>
        <span class="string">'comment'</span>}, <span class="keyword">...</span>
        <span class="string">'Value'</span>, <span class="keyword">...</span>
        {log.CS2.name,<span class="keyword">...</span>
         log.proj_conv2.method.name,     <span class="keyword">...</span>
         log.CS2.ellips.semi_major_axis, <span class="keyword">...</span>
         log.CS2.ellips.semi_minor_axis, <span class="keyword">...</span>
         log.CS2.ellips.inv_flattening,  <span class="keyword">...</span>
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,<span class="string">'Latitude of natural origin'</span>    )),<span class="keyword">...</span>
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,<span class="string">'Longitude of natural origin'</span>   )),<span class="keyword">...</span>
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,<span class="string">'False easting'</span>                 )),<span class="keyword">...</span>
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,<span class="string">'False northing'</span>                )),<span class="keyword">...</span>
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,<span class="string">'Scale factor at natural origin'</span>)),<span class="keyword">...</span>
        <span class="string">'value is equal to EPSG code'</span>});
</pre></div>
            </div>
            <div>
               <h2><a name="10">3.c Create coordinate variables: longitude</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#longitude-coordinate</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name             = <span class="string">'lon'</span>;
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {<span class="string">'col'</span>,<span class="string">'row'</span>}; <span class="comment">% !!!</span>
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'longitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'degrees_east'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'longitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.lon(:)) max(OPT.lon(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'x y'</span>); <span class="comment">% 'lat lon');</span>
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'wgs84'</span>);
</pre></div>
            </div>
            <div>
               <h2><a name="11">3.d Create coordinate variables: latitude</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#latitude-coordinate</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name             = <span class="string">'lat'</span>;
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {<span class="string">'col'</span>,<span class="string">'row'</span>}; <span class="comment">% !!!</span>
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, <span class="string">'latitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, <span class="string">'degrees_north'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, <span class="string">'latitude'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.lat(:)) max(OPT.lat(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'x y'</span>); <span class="comment">% 'lat lon');</span>
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'wgs84'</span>);
</pre></div>
            </div>
            <div>
               <h2><a name="12">3.e Create coordinate variables: coordinate system: WGS84 default</a></h2>
               <div><pre>    global ellispes: WGS 84, ED 50, INT 1924, ETRS 89 and the upcoming ETRS update etc.
    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#appendix-grid-mappings</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name         = <span class="string">'wgs84'</span>; <span class="comment">% preferred</span>
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct(<span class="string">'Name'</span>, <span class="keyword">...</span>
    {<span class="string">'name'</span>,<span class="keyword">...</span>
     <span class="string">'semi_major_axis'</span>, <span class="keyword">...</span>
     <span class="string">'semi_minor_axis'</span>, <span class="keyword">...</span>
     <span class="string">'inverse_flattening'</span>, <span class="keyword">...</span>
     <span class="string">'comment'</span>}, <span class="keyword">...</span>
     <span class="string">'Value'</span>, <span class="keyword">...</span>
     {log.CS1.name,<span class="keyword">...</span>
      log.CS1.ellips.semi_major_axis, <span class="keyword">...</span>
      log.CS1.ellips.semi_minor_axis, <span class="keyword">...</span>
      log.CS1.ellips.inv_flattening,  <span class="keyword">...</span>
     <span class="string">'value is equal to EPSG code'</span>});
</pre></div>
            </div>
            <div>
               <h2><a name="13">4   Create dependent variable</a></h2>
               <div><pre>    http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#variables
    Parameters with standard names:
    http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/</pre><pre>    The dependent variable has initially been defined on a
    curvi-linear grid in a local projection. This grid is also
    available as a curvi-linear grid in (lat,lon) space. However,
    the corodinates attribuite can only point to one set of coordinates.
    To fulfill the CF standard, we connect the variable to the lat,lon
    grid. There is no standard way to connect to the local grid as well.
    An option might be the what has been apllied above: connect the (lat ,lon)
    grid to the local grid (x,y) and vv, so at least there is a machine
    readable connection. In addition, here as specify a non-standard
    coordinates2 attribute.</pre><pre class="codeinput">   ifld = ifld + 1;
   nc(ifld).Name             = OPT.varname;
   nc(ifld).Nctype           = nc_type(OPT.val_type);
   nc(ifld).Dimension        = {<span class="string">'col'</span>,<span class="string">'row'</span>}; <span class="comment">% {'time','col','row'}</span>
   nc(ifld).Attribute(    1) = struct(<span class="string">'Name'</span>, <span class="string">'long_name'</span>      ,<span class="string">'Value'</span>, OPT.long_name    );
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'units'</span>          ,<span class="string">'Value'</span>, OPT.units        );
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'_FillValue'</span>     ,<span class="string">'Value'</span>, OPT.fillvalue    );
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'actual_range'</span>   ,<span class="string">'Value'</span>, [min(OPT.val(:)) max(OPT.val(:))]);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates'</span>    ,<span class="string">'Value'</span>, <span class="string">'lat lon'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'coordinates2'</span>   ,<span class="string">'Value'</span>, <span class="string">'x y'</span>);
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'grid_mapping'</span>   ,<span class="string">'Value'</span>, <span class="string">'epsg'</span>);
   <span class="keyword">if</span> ~isempty(OPT.standard_name)
   nc(ifld).Attribute(end+1) = struct(<span class="string">'Name'</span>, <span class="string">'standard_name'</span>  ,<span class="string">'Value'</span>, OPT.standard_name);
   <span class="keyword">end</span>
</pre></div>
            </div>
            <div>
               <h2><a name="14">5.a Create all variables with attributes</a></h2>
               <div><pre class="codeinput">   <span class="keyword">for</span> ifld=1:length(nc)
      nc_addvar(ncfile, nc(ifld));
   <span class="keyword">end</span>
</pre></div>
            </div>
            <div>
               <h2><a name="15">5.b Fill all variables</a></h2>
               <div><pre class="codeinput">   nc_varput(ncfile, <span class="string">'x'</span>            , OPT.x         );
   nc_varput(ncfile, <span class="string">'y'</span>            , OPT.y         );
   nc_varput(ncfile, <span class="string">'epsg'</span>         , OPT.epsg.code );
   nc_varput(ncfile, <span class="string">'lon'</span>          , OPT.lon       );
   nc_varput(ncfile, <span class="string">'lat'</span>          , OPT.lat       );
   nc_varput(ncfile, <span class="string">'wgs84'</span>        , OPT.wgs84.code);
   nc_varput(ncfile, OPT.varname    , OPT.val       );
</pre></div>
            </div>
            <div>
               <h2><a name="16">6   Check file summary</a></h2>
               <div><pre class="codeinput">   nc_dump(ncfile);
</pre><pre class="codeoutput">netCDF e:\Temp\tp10b47dd6_f8f5_4f3a_8a47_33768e5af4ab\nc_cf_grid_write_x_y_curvilinear_tutorial.nc { 

dimensions:
	col = 3 ;
	row = 5 ;


variables:
	// Preference 'PRESERVE_FVD':  false,
	// dimensions consistent with ncBrowse, not with native MATLAB netcdf package.
	single x(col,row), shape = [3 5]
		x:long_name = "x Rijksdriehoek" 
		x:units = "m" 
		x:standard_name = "projection_x_coordinate" 
		x:actual_range = 481128 929333 
		x:coordinates = "lat lon" 
		x:grid_mapping = "epsg" 
	single y(col,row), shape = [3 5]
		y:long_name = "y Rijksdriehoek" 
		y:units = "m" 
		y:standard_name = "projection_y_coordinate" 
		y:actual_range = 5.46907e+006 6.2314e+006 
		y:coordinates = "lat lon" 
		y:grid_mapping = "epsg" 
	int32 epsg([]), shape = [1]
		epsg:name = "WGS 84 / UTM zone 31N" 
		epsg:grid_mapping_name = "Transverse Mercator" 
		epsg:semi_major_axis = 6.37814e+006 
		epsg:semi_minor_axis = 6.35675e+006 
		epsg:inverse_flattening = 298.257 
		epsg:latitude_of_projection_origin = 0 
		epsg:longitude_of_projection_origin = 3 
		epsg:false_easting = 500000 
		epsg:false_northing = 0 
		epsg:scale_factor_at_projection_origin = 0.9996 
		epsg:comment = "value is equal to EPSG code" 
	single lon(col,row), shape = [3 5]
		lon:long_name = "longitude" 
		lon:units = "degrees_east" 
		lon:standard_name = "longitude" 
		lon:actual_range = 2.70711 9 
		lon:coordinates = "x y" 
		lon:grid_mapping = "wgs84" 
	single lat(col,row), shape = [3 5]
		lat:long_name = "latitude" 
		lat:units = "degrees_north" 
		lat:standard_name = "latitude" 
		lat:actual_range = 49.2235 56.1213 
		lat:coordinates = "x y" 
		lat:grid_mapping = "wgs84" 
	int32 wgs84([]), shape = [1]
		wgs84:name = "WGS 84" 
		wgs84:semi_major_axis = 6.37814e+006 
		wgs84:semi_minor_axis = 6.35675e+006 
		wgs84:inverse_flattening = 298.257 
		wgs84:comment = "value is equal to EPSG code" 
	single depth(col,row), shape = [3 5]
		depth:long_name = "bottom depth" 
		depth:units = "m" 
		depth:_FillValue = NaN 
		depth:actual_range = 1 15 
		depth:coordinates = "lat lon" 
		depth:coordinates2 = "x y" 
		depth:grid_mapping = "epsg" 
		depth:standard_name = "sea_floor_depth_below_geoid" 


//global attributes:
		:title = "" 
		:institution = "" 
		:source = "" 
		:history = "tranformation to netCDF: $HeadURL: https://repos.deltares.nl/repos/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_curvilinear_tutorial.m $" 
		:references = "" 
		:email = "" 
		:comment = "" 
		:version = "" 
		:Conventions = "CF-1.4" 
		:CF:featureType = "Grid" 
		:terms_for_use = "These data can be used freely for research purposes provided that the following source is acknowledged: " 
		:disclaimer = "This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE." 
}
</pre></div>
            </div>
            <div>
               <h2><a name="17">7.a Load the data: using the variable names from nc_dump</a></h2>
               <div><pre class="codeinput">   Da.dep   = nc_varget(ncfile,<span class="string">'depth'</span>);
   Da.lat   = nc_varget(ncfile,<span class="string">'lon'</span>);
   Da.lon   = nc_varget(ncfile,<span class="string">'lat'</span>)
</pre><pre class="codeoutput">
Da = 

    dep: [3x5 double]
    lat: [3x5 single]
    lon: [3x5 single]

</pre></div>
            </div>
            <div>
               <h2><a name="18">7.b Load the data: using standard_names and coordinate attribute</a></h2>
               <div><pre class="codeinput">   depname  = nc_varfind(ncfile,<span class="string">'attributename'</span>, <span class="string">'standard_name'</span>, <span class="string">'attributevalue'</span>, <span class="string">'sea_floor_depth_below_geoid'</span>)
   Db.z     = nc_varget(ncfile,depname);

   coords   = nc_attget(ncfile,depname,<span class="string">'coordinates'</span>);
  [ax1,coords] = strtok(coords); ax2 = strtok(coords);
   <span class="keyword">if</span> strcmpi(nc_attget(ncfile,ax1,<span class="string">'standard_name'</span>),<span class="string">'latitude'</span>)
   Db.lat   = nc_varget(ncfile,ax1);
   Db.lon   = nc_varget(ncfile,ax2)
   <span class="keyword">else</span>
   Db.lat   = nc_varget(ncfile,ax2);
   Db.lon   = nc_varget(ncfile,ax1)
   <span class="keyword">end</span>
</pre><pre class="codeoutput">
depname =

depth


Db = 

      z: [3x5 double]
    lat: [3x5 single]
    lon: [3x5 single]

</pre></div>
            </div>
            <div>
               <h2><a name="19">7.c Load the data: using a dedicated function developed for grids</a></h2>
               <div><pre class="codeinput">   [Dc,Mc] = nc_cf_grid(ncfile,OPT.varname)
</pre><pre class="codeoutput">
Dc = 

      lon: [3x5 single]
      lat: [3x5 single]
    depth: [3x5 double]


Mc = 

      lon: [1x1 struct]
      lat: [1x1 struct]
    depth: [1x1 struct]

</pre><img vspace="5" hspace="5" src="nc_cf_grid_write_x_y_curvilinear_tutorial_01.png" relsrc="nc_cf_grid_write_x_y_curvilinear_tutorial_01.png"> </div>
            </div>
         </div>
         <p class="footer"><br>
            this tutorial is based on: <a class="matlabhref" href="matlab:edit('nc_cf_grid_write_x_y_curvilinear_tutorial');" browserhref="http://crucible.delftgeosystems.nl/browse/~raw,r=2703/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_curvilinear_tutorial.m">nc_cf_grid_write_x_y_curvilinear_tutorial.m (revision: 2703)</a><br>
Published with MATLAB&reg; 7.10<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Create netCDF-CF of curvilinear x-y grid
%
%  example of how to make a netCDF file with CF conventions of a 
%  variable that is defined on a grid that is curvilinear
%  in a x-y coordinate system. In this case 
%  the dimensions (m,n) do not coincide with the coordinate axes.
%
%  This case is partly described in:
%  http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
%  as "Horizontal Coordinate Reference Systems, Grid Mappings, and Projections".
%
%  An example of a curvi-linear x,y grid is for instance
%  the grid of a regional general circulation model such
%  as Delft3D, ROMS or POM that has been ddesigned to follow
%  coastal feartures smoothly.
%
%    ^ latitude (degrees_north)           ^ y(m)
%    |         x                          |             x             
%    | ncols /   \                        |     ncols /   \           
%    |     /  /\   \              coordinate        /  /\   \         
%    |   /   /15\    \          transformation    /   /15\    \       
%    |  x  /10   \     \       <==============>  x  /10   \     \     
%    |    <5     14\     \                |        <5     14\     \   
%    |     \   9    \      \              |         \   9    \      \ 
%    |      \4       \      |             |          \4       \      |
%    |       \        \     |             |           \        \     |
%    |        )3  8  xx)    | nrows       |            )3  8  xx)    |
%    |       /        /     |             |           /        /     |
%    |      /2       /      |             |          /2       /      |
%    |     /   7    /      /              |         /   7    /      / 
%    |    <1     12/     /                |        <1     12/     /   
%    |     \6    /     /                  |         \6    /     /     
%    |       \11/    /                    |          \11/    /        
%    |        \/   x                      |           \/   x          
%    |                                    |                           
%    +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH> longitude   +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH> x
%                        (degrees_east)                          (m)
%
% Note that ncBrowse does not contain plot support for 
% curvi-linear grids, so ncBrowse will display the same 
% rectangular plot as for the netCDF file created by
% NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL, albeit with
% different axes annotations (col/row instead of lat/lon).
%
%See also: SNCTOOLS, NC_CF_GRID, NC_CF_GRID_WRITE,
%          NC_CF_GRID_WRITE_LAT_LON_ORTHOGONAL_TUTORIAL, 
%          NC_CF_GRID_WRITE_LAT_LON_CURVILINEAR_TUTORIAL, 
%          NC_CF_GRID_WRITE_X_Y_ORTHOGONAL_TUTORIAL,
%          NC_CF_STATIONTIMESERIES
%
% This tool is part of <a href="http://www.OpenEarth.eu">OpenEarthTools</a> under the <a href="http://www.gnu.org/licenses/gpl.html">GPL</a> license.

%% Define meta-info: global: x,y matrices <> lat,lon matrices

   OPT.title                  = '';
   OPT.institution            = '';
   OPT.source                 = '';
   OPT.history                = ['tranformation to netCDF: $HeadURL: https://repos.deltares.nl/repos/OpenEarthTools/trunk/matlab/io/netcdf/nctools/nc_cf_grid_write_x_y_curvilinear_tutorial.m $'];
   OPT.references             = '';
   OPT.email                  = '';
   OPT.comment                = '';
   OPT.version                = '';
   OPT.acknowledge            =['These data can be used freely for research purposes provided that the following source is acknowledged: ',OPT.institution];
   OPT.disclaimer             = 'This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.';
   
%% Define dimensions/coordinates
%  exactly same grid same nc_cf_grid_write_lat_lon_curvilinear_tutorial.m

   lon1                       = [2 4 6];
   lat1                       = [50 51 52 53 54];
  [lon2,lat2]                 = ndgrid(lon1,lat1);
   ang                        = [-15 0 15 30 45;-15 0 15 30 45;-15 0 15 30 45];
   OPT.lat                    = lat2 + sind(ang).*lon2./2;
   OPT.lon                    = lon2 + cosd(ang).*lon2./2; clear lon1 lon2 lat1 lat2

   OPT.ncols                  = size(OPT.lon,1);
   OPT.nrows                  = size(OPT.lat,2);
   OPT.lat_type               = 'single'; % 'single', 'double' for high-resolution data (eps 1m)
   OPT.lon_type               = 'single'; % 'single', 'double' for high-resolution data (eps 1m)

   OPT.epsg.code              = 32631; % epsg code of local projection
   OPT.wgs84.code             = 4326;  % epsg code of global grid
   % http://www.epsg-registry.org/
   % in the case of a grid defined in a local x-y 
   % projection, the properties of the grid in a WGS84
   % lat,lon system do not have to be specified here, but 
   % can be retrieved from the log of the coordinate 
   % transformation carried out by convertCoordinates:
   % get (x,y) associated with each vertex (lat,lon), note order (OPT.lon,OPT.lat ...

  [OPT.x,OPT.y,log]           = convertCoordinates(OPT.lon,OPT.lat,'CS1.code',OPT.wgs84.code,'CS2.code',OPT.epsg.code);

  %% Define variable (define some data)

   OPT.val                    = [1 2 3 4 5;6 7 8 9 10;11 12 nan 14 15]; % use ncols as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)
   OPT.varname                = 'depth';       % free to choose: will appear in netCDF tree
   OPT.units                  = 'm';           % from UDunits package: http://www.unidata.ucar.edu/software/udunits/
   OPT.long_name              = 'bottom depth';% free to choose: will appear in plots
   OPT.standard_name          = 'sea_floor_depth_below_geoid'; % or 'altitude'
   OPT.val_type               = 'single';      % 'single' or 'double'
   OPT.fillvalue              = nan;
   
%% 1.a Create netCDF file

   ncfile = fullfile(fileparts(mfilename('fullpath')),[mfilename,'.nc']);

   nc_create_empty (ncfile)

%% 1.b Add overall meta info
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#description-of-file-contents
   
   nc_attput(ncfile, nc_global, 'title'         , OPT.title);
   nc_attput(ncfile, nc_global, 'institution'   , OPT.institution);
   nc_attput(ncfile, nc_global, 'source'        , OPT.source);
   nc_attput(ncfile, nc_global, 'history'       , OPT.history);
   nc_attput(ncfile, nc_global, 'references'    , OPT.references);
   nc_attput(ncfile, nc_global, 'email'         , OPT.email);

   nc_attput(ncfile, nc_global, 'comment'       , OPT.comment);
   nc_attput(ncfile, nc_global, 'version'       , OPT.version);

   nc_attput(ncfile, nc_global, 'Conventions'   , 'CF-1.4');
   nc_attput(ncfile, nc_global, 'CF:featureType', 'Grid');  % https://cf-pcmdi.llnl.gov/trac/wiki/PointObservationConventions

   nc_attput(ncfile, nc_global, 'terms_for_use' , OPT.acknowledge);
   nc_attput(ncfile, nc_global, 'disclaimer'    , OPT.disclaimer);
      
%% 2   Create matrix span dimensions
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#dimensions   
   
   nc_add_dimension(ncfile, 'col', OPT.ncols); % !!! use this as 1st array dimension to get correct plot in ncBrowse (snctools swaps for us)
   nc_add_dimension(ncfile, 'row', OPT.nrows); % !!! use this as 2nd array dimension to get correct plot in ncBrowse (snctools swaps for us)

   % You might insert a vector 'col' that runs max(x):-dx:min(x) to have
   % the arcGIS ASCII file approach of having upper-left corner of 
   % the data matrix at index (1,1) rather than the default of having the 
   % lower-left corner of the data matrix  at index (1,1).

%  nc_add_dimension(ncfile, 'time', 1); % if you would like to include more instances of the same grid, 
                                        % you can optionally use 'time' as a 3rd dimension. see 
                                        % nc_cf_stationTimeSeries_write_tutorial for info on time.          

%% 3.a Create coordinate variables: x and y

   clear nc;ifld = 1;
   nc(ifld).Name             = 'x';
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {'col','row'}; % !!!
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'x Rijksdriehoek');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'm');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'projection_x_coordinate'); % standard name
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.x(:)) max(OPT.x(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'epsg');

   ifld = ifld + 1;
   nc(ifld).Name             = 'y';
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {'col','row'}; % !!!
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'y Rijksdriehoek');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'm');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'projection_y_coordinate'); % standard name
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.y(:)) max(OPT.y(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'epsg');

%% 3.b Create coordinate variables: coordinate system: epsg
%      http://www.epsg-registry.org/
   
   ifld = ifld + 1;
   nc(ifld).Name         = 'epsg';
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct('Name', ...
       {'name',...
        'grid_mapping_name', ...
        'semi_major_axis', ...
        'semi_minor_axis', ...
        'inverse_flattening', ...
        'latitude_of_projection_origin', ...
        'longitude_of_projection_origin', ...
        'false_easting', ...
        'false_northing', ...
        'scale_factor_at_projection_origin', ...
        'comment'}, ...
        'Value', ...
        {log.CS2.name,...
         log.proj_conv2.method.name,     ...
         log.CS2.ellips.semi_major_axis, ...
         log.CS2.ellips.semi_minor_axis, ...
         log.CS2.ellips.inv_flattening,  ...
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,'Latitude of natural origin'    )),...
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,'Longitude of natural origin'   )),...
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,'False easting'                 )),...
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,'False northing'                )),...
         log.proj_conv2.param.value(strcmp(log.proj_conv2.param.name,'Scale factor at natural origin')),...
        'value is equal to EPSG code'});

%% 3.c Create coordinate variables: longitude
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#longitude-coordinate

   ifld = ifld + 1;
   nc(ifld).Name             = 'lon';
   nc(ifld).Nctype           = nc_type(OPT.lon_type);
   nc(ifld).Dimension        = {'col','row'}; % !!!
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'longitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'degrees_east');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'longitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.lon(:)) max(OPT.lon(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'x y'); % 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'wgs84');

%% 3.d Create coordinate variables: latitude
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#latitude-coordinate
   
   ifld = ifld + 1;
   nc(ifld).Name             = 'lat';
   nc(ifld).Nctype           = nc_type(OPT.lat_type);
   nc(ifld).Dimension        = {'col','row'}; % !!!
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', 'latitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', 'degrees_north');
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', 'latitude');
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.lat(:)) max(OPT.lat(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'x y'); % 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'wgs84');

%% 3.e Create coordinate variables: coordinate system: WGS84 default
%      global ellispes: WGS 84, ED 50, INT 1924, ETRS 89 and the upcoming ETRS update etc.
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#grid-mappings-and-projections
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#appendix-grid-mappings
   
   ifld = ifld + 1;
   nc(ifld).Name         = 'wgs84'; % preferred
   nc(ifld).Nctype       = nc_int;
   nc(ifld).Dimension    = {};
   nc(ifld).Attribute = struct('Name', ...
    {'name',...
     'semi_major_axis', ...
     'semi_minor_axis', ...
     'inverse_flattening', ...
     'comment'}, ...
     'Value', ...
     {log.CS1.name,...
      log.CS1.ellips.semi_major_axis, ...
      log.CS1.ellips.semi_minor_axis, ...
      log.CS1.ellips.inv_flattening,  ...
     'value is equal to EPSG code'});

%% 4   Create dependent variable
%      http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.4/cf-conventions.html#variables
%      Parameters with standard names:
%      http://cf-pcmdi.llnl.gov/documents/cf-standard-names/standard-name-table/current/
%
%      The dependent variable has initially been defined on a 
%      curvi-linear grid in a local projection. This grid is also 
%      available as a curvi-linear grid in (lat,lon) space. However,
%      the corodinates attribuite can only point to one set of coordinates.
%      To fulfill the CF standard, we connect the variable to the lat,lon 
%      grid. There is no standard way to connect to the local grid as well.
%      An option might be the what has been apllied above: connect the (lat ,lon)
%      grid to the local grid (x,y) and vv, so at least there is a machine
%      readable connection. In addition, here as specify a non-standard 
%      coordinates2 attribute.

   ifld = ifld + 1;
   nc(ifld).Name             = OPT.varname;
   nc(ifld).Nctype           = nc_type(OPT.val_type);
   nc(ifld).Dimension        = {'col','row'}; % {'time','col','row'}
   nc(ifld).Attribute(    1) = struct('Name', 'long_name'      ,'Value', OPT.long_name    );
   nc(ifld).Attribute(end+1) = struct('Name', 'units'          ,'Value', OPT.units        );
   nc(ifld).Attribute(end+1) = struct('Name', '_FillValue'     ,'Value', OPT.fillvalue    );
   nc(ifld).Attribute(end+1) = struct('Name', 'actual_range'   ,'Value', [min(OPT.val(:)) max(OPT.val(:))]);
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates'    ,'Value', 'lat lon');
   nc(ifld).Attribute(end+1) = struct('Name', 'coordinates2'   ,'Value', 'x y');
   nc(ifld).Attribute(end+1) = struct('Name', 'grid_mapping'   ,'Value', 'epsg');
   if ~isempty(OPT.standard_name)
   nc(ifld).Attribute(end+1) = struct('Name', 'standard_name'  ,'Value', OPT.standard_name);
   end
      
%% 5.a Create all variables with attributes
   
   for ifld=1:length(nc)
      nc_addvar(ncfile, nc(ifld));   
   end
      
%% 5.b Fill all variables

   nc_varput(ncfile, 'x'            , OPT.x         );
   nc_varput(ncfile, 'y'            , OPT.y         );
   nc_varput(ncfile, 'epsg'         , OPT.epsg.code );
   nc_varput(ncfile, 'lon'          , OPT.lon       );
   nc_varput(ncfile, 'lat'          , OPT.lat       );
   nc_varput(ncfile, 'wgs84'        , OPT.wgs84.code);
   nc_varput(ncfile, OPT.varname    , OPT.val       );
      
%% 6   Check file summary
   
   nc_dump(ncfile);

%% 7.a Load the data: using the variable names from nc_dump

   Da.dep   = nc_varget(ncfile,'depth');
   Da.lat   = nc_varget(ncfile,'lon');
   Da.lon   = nc_varget(ncfile,'lat')

%% 7.b Load the data: using standard_names and coordinate attribute

   depname  = nc_varfind(ncfile,'attributename', 'standard_name', 'attributevalue', 'sea_floor_depth_below_geoid')
   Db.z     = nc_varget(ncfile,depname);

   coords   = nc_attget(ncfile,depname,'coordinates');
  [ax1,coords] = strtok(coords); ax2 = strtok(coords);
   if strcmpi(nc_attget(ncfile,ax1,'standard_name'),'latitude')
   Db.lat   = nc_varget(ncfile,ax1);
   Db.lon   = nc_varget(ncfile,ax2)
   else
   Db.lat   = nc_varget(ncfile,ax2);
   Db.lon   = nc_varget(ncfile,ax1)
   end

%% 7.c Load the data: using a dedicated function developed for grids

   [Dc,Mc] = nc_cf_grid(ncfile,OPT.varname)

##### SOURCE END #####
-->
   </body>
</html>