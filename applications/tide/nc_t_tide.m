function varargout = nc_t_tide(varargin)
%NC_T_TIDE    t_tide with netCDF output
%
%   <D> = nc_t_tide(t,var,<keyword,value>)
%
% performs a t_tide tidal analysis and saves result as netCDF file.
%
%   <D> = nc_t_tide(filename,<keyword,value>)
%
% saves ascii 'output' file as generated by t_tide as netCDF file.
%
% Optionally struct D with al data is returned, it is empty when
% an error is encounted. Note non-equidistant time-spacing is allowed.
%
% For list of <keyword,value> call nc_t_tide()
%
%See also: T_TIDE, NC_T_TIDE_COMPARE, UTide

% TO DO: start using native matlab ncwritschema

%   --------------------------------------------------------------------
%   Copyright (C) 2010 Deltares
%       Gerben J. de Boer
%
%       gerben.deboer@deltares.nl	
%
%       Deltares
%       P.O. Box 177
%       2600 MH Delft
%       The Netherlands
%
%   This library is free software: you can redistribute it and/or
%   modify it under the terms of the GNU Lesser General Public
%   License as published by the Free Software Foundation, either
%   version 2.1 of the License, or (at your option) any later version.
%
%   This library is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%   Lesser General Public License for more details.
%
%   You should have received a copy of the GNU Lesser General Public
%   License along with this library. If not, see <http://www.gnu.org/licenses/>.
%   --------------------------------------------------------------------

% This tool is part of <a href="http://OpenEarth.nl">OpenEarthTools</a>.
% OpenEarthTools is an online collaboration to share and manage data and 
% programming tools in an open source, version controlled environment.
% Sign up to recieve regular updates of this function, and to contribute 
% your own tools.

%% Version <http://svnbook.red-bean.com/en/1.5/svn.advanced.props.special.keywords.html>
% Created: 17 Aug 2010
% Created with Matlab version: 7.7.0.471 (R2008b)

% $Id$
% $Date$
% $Author$
% $Revision$
% $HeadURL$
% $Keywords: $

%% Input

   OPT.platform_id   = ' ';
   OPT.platform_name = ' ';
   OPT.period        = [];
   OPT.lat           = NaN;
   OPT.lon           = NaN;
   OPT.units         = '?';
   OPT.ascfile       = '';
   OPT.ncfile        = '';
   OPT.ddatenumeps   = 1e-8;
   OPT.synth         = 2;
   OPT.sort          = 'freq';
   OPT.refdatenum    = datenum(1970,1,1);
   
   OPT.title         = ' ';
   OPT.institution   = ' ';
   OPT.source        = ' ';
   OPT.history       = ' ';
   OPT.email         = ' ';

   if nargin==0
      varargout = {OPT};
      return
   end

%% Tidal analysis incl. temporal equidistance check

if odd(nargin)

      fname = varargin{1};
      
      if isempty(OPT.ncfile)
      OPT.ncfile = [filenameext(fname),'.nc'];
      end

      
      OPT       = setproperty(OPT,varargin{2:end});
      D         = t_tide_read(fname);
      OPT.synth = '{unknown, probably 2 (t_tide default)}'; % unknown, not in output

else

      t   = varargin{1};
      var = varargin{2};
   
      OPT = setproperty(OPT,varargin{3:end});
   
      if ~isempty(OPT.period)
      mask = find(( t >= OPT.period(1)) & (t <= OPT.period(end)));
      else
      mask = 1:length(t);
      OPT.period = [t(1) t(end)];
      end
      dt = diff(t(mask)).*24; % hour

      if length(unique([dt])) > 1
% Not any more with OET t_tide extension
%          if (max(dt) - min(dt)) > OPT.ddatenumeps
%             fprintf(2,'%s\n',['No equidistant time intervals: range: ',num2str(min(dt)),' - ',num2str(max(dt))])
%             varargout = {[]};
%             return
%          end
         t_tide_err = 'lin';
      else
         dt = dt(1); % in hours
         t_tide_err = 'cboot';
      end
      
      output = 'none';
      if ~isempty(OPT.ascfile)
      mkdir(fileparts(OPT.ascfile));
      output = [OPT.ascfile];
      end
     
      [tidestruc,pout]=t_tide(var(mask),...
                 'latitude'  ,OPT.lat,... % required for nodal corrections
                 'start'     ,t(mask(1)),...
                 'interval'  ,dt,... % in hours
                 'output'    ,output,...
                 'error'     ,t_tide_err,...
                 'sort'      ,OPT.sort,...
                 'synth'     ,OPT.synth);

   %% Collect relevant data in struct, as if returned by D = nc2struct()                 

      D.component_name  = tidestruc.name;
      D.frequency       = tidestruc.freq;
      if isreal(var)
      V.data.fmaj       = tidestruc.tidecon(:,1);V.name.fmaj = 'amplitude'      ;V.units.fmaj = OPT.units     ;V.long_name.fmaj = 'amplitude of tidal component';
      V.data.emaj       = tidestruc.tidecon(:,2);V.name.emaj = 'amplitude_error';V.units.emaj = OPT.units     ;V.long_name.emaj = 'estimate of error of amplitude of tidal component';
      V.data.pha        = tidestruc.tidecon(:,3);V.name.pha  = 'phase'          ;V.units.pha  = 'degrees'     ;V.long_name.pha  = 'phase of tidal component';
      V.data.epha       = tidestruc.tidecon(:,4);V.name.epha = 'phase_error'    ;V.units.epha = 'degrees'     ;V.long_name.epha = 'estimate of error of phase of tidal component';
      else
      V.data.fmaj       = tidestruc.tidecon(:,1);V.name.fmaj = 'sema'           ;V.units.fmaj = OPT.units     ;V.long_name.fmaj = 'major ellipse axis of tidal component';
      V.data.emaj       = tidestruc.tidecon(:,2);V.name.emaj = 'sema_error'     ;V.units.emaj = OPT.units     ;V.long_name.emaj = 'estimate of error of major ellipse axis of tidal component';
      V.data.fmin       = tidestruc.tidecon(:,3);V.name.fmin = 'semi'           ;V.units.fmin = OPT.units     ;V.long_name.fmin = 'minor ellipse axis of tidal component';
      V.data.emin       = tidestruc.tidecon(:,4);V.name.emin = 'semi_error'     ;V.units.emin = OPT.units     ;V.long_name.emin = 'estimate of error of minor ellipse axis of tidal component';
      V.data.finc       = tidestruc.tidecon(:,5);V.name.finc = 'inc'            ;V.units.finc = 'degrees_true';V.long_name.finc = 'ellipse orientation';
      V.data.einc       = tidestruc.tidecon(:,6);V.name.einc = 'inc_error'      ;V.units.einc = 'degrees_true';V.long_name.einc = 'estimate of error of ellipse orientation';
      V.data.pha        = tidestruc.tidecon(:,7);V.name.pha  = 'phase'          ;V.units.pha  = 'degrees'     ;V.long_name.pha  = 'phase of tidal component';
      V.data.epha       = tidestruc.tidecon(:,8);V.name.epha = 'phase_error'    ;V.units.epha = 'degrees'     ;V.long_name.epha = 'estimate of error of phase of tidal component';
      end
      D.snr             = (V.data.fmaj./V.data.emaj).^2;  % signal to noise ratio (t_tide line 523)
      
      end
      D.significance    = D.snr > OPT.synth;

      D.platform_id     = OPT.platform_id  ;  
      D.platform_name   = OPT.platform_name;
      D.longitude       = OPT.lon;
      D.latitude        = OPT.lat;

%% Save struct to netCDF file
      
   nc_create_empty(OPT.ncfile);
   
   nc_attput(OPT.ncfile, nc_global, 'title'         , OPT.title);
   nc_attput(OPT.ncfile, nc_global, 'institution'   , OPT.institution);
   nc_attput(OPT.ncfile, nc_global, 'source'        , OPT.source);
   nc_attput(OPT.ncfile, nc_global, 'history'       , OPT.history);
   nc_attput(OPT.ncfile, nc_global, 'references'    , 'Pawlowicz, R., B. Beardsley, and S. Lentz, "Classical Tidal Harmonic Analysis Including Error Estimates in MATLAB using T_TIDE", Computers and Geosciences, 2002. http://dx.doi.org/10.1016/S0098-3004(02)00013-4');
   nc_attput(OPT.ncfile, nc_global, 'email'         , OPT.email);
   
   nc_attput(OPT.ncfile, nc_global, 'version'       , '$HeadURL$ $Id$');
   nc_attput(OPT.ncfile, nc_global, 'Conventions'   , 'CF-1.4');
   nc_attput(OPT.ncfile, nc_global, 'disclaimer'    , 'This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.');
   
   % TO DO: add other meta-info from t_tide such as history and stuff from t_tide ASCII file
   
   nc_adddim      (OPT.ncfile,'frequency',length(D.frequency));
   nc_adddim      (OPT.ncfile,'strlen0'  ,1);
   nc_adddim      (OPT.ncfile,'strlen1'  ,size(char(D.component_name),2));
   if ~isempty(D.platform_id)
   nc_adddim      (OPT.ncfile,'strlen2'  ,length(D.platform_id));
   end
   if ~isempty(D.platform_name)
   nc_adddim      (OPT.ncfile,'strlen3'  ,length(D.platform_name));
   end
   nc_adddim      (OPT.ncfile,'time'     ,1);
   nc_adddim      (OPT.ncfile,'bounds'   ,2);
  
  if ~isempty(D.platform_id)   
   nc.Name = 'platform_id';
   nc.Datatype     = 'char';
   nc.Dimension    = {'strlen0','strlen2'}; % 2D, otherwise matlab does not load it correctly
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'Rijkswaterstaat DONAR code of station');
   nc.Attribute(2) = struct('Name', 'standard_name'  ,'Value', 'platform_id');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,D.platform_id(:)');clear nc
  end
  if ~isempty(D.platform_name)   
   nc.Name = 'platform_name';
   nc.Datatype     = 'char';
   nc.Dimension    = {'strlen0','strlen3'}; % 2D, otherwise matlab does not load it correctly
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'name of station');
   nc.Attribute(2) = struct('Name', 'standard_name'  ,'Value', 'platform_name');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,D.platform_name(:)');clear nc
  end
  if ~(isempty(D.longitude) | isempty(D.latitude))
   nc.Name = 'longitude';
   nc.Datatype     = 'double';
   nc.Dimension    = {};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'longitude');
   nc.Attribute(2) = struct('Name', 'standard_name'  ,'Value', 'longitude');
   nc.Attribute(3) = struct('Name', 'units'          ,'Value', 'degrees_east');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,D.longitude);clear nc

   nc.Name = 'latitude';
   nc.Datatype     = 'double';
   nc.Dimension    = {};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'latitude');
   nc.Attribute(2) = struct('Name', 'standard_name'  ,'Value', 'latitude');
   nc.Attribute(3) = struct('Name', 'units'          ,'Value', 'degrees_north');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,D.latitude);clear nc
  end
   % TO DO: connect time to amp/phase

   nc.Name = 'time';
   nc.Datatype     = 'double';
   nc.Dimension    = {'time'};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'begin of interval of tidal analysis');
   nc.Attribute(2) = struct('Name', 'standard_name'  ,'Value', 'time');
   nc.Attribute(3) = struct('Name', 'units'          ,'Value',['days since ',datestr(OPT.refdatenum,'yyyy-mm-dd HH:MM')]);
   nc.Attribute(4) = struct('Name', 'bounds'         ,'Value', 'period');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,t(mask(1)) - OPT.refdatenum);clear nc

   nc.Name = 'period';
   nc.Datatype     = 'double';
   nc.Dimension    = {'time','bounds'};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'begin and end of interval of tidal analysis');
   nc.Attribute(2) = struct('Name', 'standard_name'  ,'Value', 'time');
   nc.Attribute(3) = struct('Name', 'units'          ,'Value',['days since ',datestr(OPT.refdatenum,'yyyy-mm-dd HH:MM')]);
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,squeeze(t(mask([1 end]))) - OPT.refdatenum);clear nc % 2D array so shape is relevant

   nc.Name = 'component_name';
   nc.Datatype     = 'char';
   nc.Dimension    = {'frequency','strlen1'};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'name of tidal constituent');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,D.component_name);clear nc
   
   nc.Name = 'frequency';
   nc.Datatype     = 'double';
   nc.Dimension    = {'frequency'};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'frequency');
   nc.Attribute(2) = struct('Name', 'units'          ,'Value', '1/hour');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,D.frequency);clear nc
   
fldnames = fieldnames(V.data);
for ifld=1:length(fldnames)
   fldname = fldnames{ifld};
   nc.Name = V.name.(fldname);
   nc.Datatype     = 'double';
   nc.Dimension    = {'frequency'};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', V.long_name.(fldname));
   nc.Attribute(2) = struct('Name', 'units'          ,'Value',     V.units.(fldname));
   nc.Attribute(3) = struct('Name', 'cell_methods'   ,'Value', 'time: period area: point');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,V.data.(fldname));clear nc

end
   
   nc.Name = 'significance';
   nc.Datatype     = 'int';
   nc.Dimension    = {'frequency'};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value',['whether component is significant (1) or not (0)']);
   nc.Attribute(2) = struct('Name', 'flag_values'    ,'Value',[0 1]);
   nc.Attribute(3) = struct('Name', 'flag_meanings'  ,'Value',['"insignificant" "significant(1, snr > ',num2str(OPT.synth),')"']);
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,int8(D.significance));clear nc
   % TO DO flag_values
   % TO DO flag_meanings
   
   nc.Name = 'snr';
   nc.Datatype     = 'double';
   nc.Dimension    = {'frequency'};
   nc.Attribute(1) = struct('Name', 'long_name'      ,'Value', 'signal to noise ration');
   nc.Attribute(1) = struct('Name', 'comment'        ,'Value', '(amplitude/amplitude_error)^2');
   nc_addvar         (OPT.ncfile,nc);
   nc_varput         (OPT.ncfile,nc.Name,D.snr);clear nc

%% output

   if nargout==1
      varargout = {D};
   end   
