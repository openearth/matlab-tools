function [result] = donar_dia2donarMat(sourcename,targetpath,xlsfilepath,cellstr_fields)
%DONAR_DIA2NC  read donar *.dia file into struct (BETA) and generate an NC
%file.
%
%   STRUCT - DONAR_DIA2NC(FNAME,CELLSTR_FIELDS) reads and harvest
%   the information from a donar *.dia file. FNAME is a string with the
%   absolute path to the file. CELLSTR_FIELDS is a string cell array with
%   the names of the fields as found in the file from left to right.
%
%   (!) There are several key words that should be used in the
%   cellstr_fields: 
%       'datestring': The fnuction will use this field to generate a matlab
%                   datenum.
%       'timestring': The function will use this field to generate a matlab
%                   datenum.
%       'longitude': The function will use this field to generate the
%                   locations of the measurement
%       'latitude': The function will use this field to generate the
%                   locations of the measurement
%       'variable': The function will use this field to generate the
%                   the values of the measurements
%
%   ABSENCE OF THIS TWO KEYWORDS WILL RESULT IN NO MATLAB DATENUM
%   GENERATION
%
%   D = donar_dia_read('f:\R\DenHelderJaar2008Debietdia.dia',{'LocationE','LocationN','id','dateString','timeString','variable'});
%  
% with the fields ;datenum' + 'value' and the following (unprocessed) meta-info fields.
%
% Written by Ivan Garcia: garcia_in@deltares.nl, based on the script
% written by Bas Hoonhout



    warning('beta')
    
    numcol = length(cellstr_fields);
    fid   = fopen(sourcename);
    theformat = '%s';
    
    % Lets read the xls file of standard names and fields.
    warning off
        [~,~,xls_standard_names]  = xlsread(xlsfilepath,'standar.name');
        [~,~,xls_standard_fields] = xlsread(xlsfilepath,'dia.fields')
        error
    warning on
    
    
    % Create an appropriate reading format. textscan(...,'%f%f%f%s',...) if
    % three columns, for instance (last one sotres '/0').
    for i=numcol:-1:1,
        if strcmpi(cellstr_fields{i},'datestring') || strcmpi(cellstr_fields{i},'timestring')
            theformat = ['%f',theformat];
        else
            theformat = ['%f',theformat];
        end
    end
    
    
    
    % The dia file that I am dealing with is divided into several batches
    % (stukjes) of data, separated by headers (Hdr). Lets read the file
    % identifying the separate batches.
    iStuk = 1;
    iHdr = 1;
    result(1) = ncstruct;
    while 1
        
        % Read a data line
        temp = textscan(fid,theformat,'delimiter',';:');
        
        if isempty(temp{1})
            % It did not read anything?
            % Must not fit the format "theformat"; it might be a hdr
            temp = read_hdr(fid,xls_standard_names,xls_standard_fields);
            
            if ~isstruct(temp), 
                
                % It is actually the end of the file
                numhdr = iHdr-1;
                numstuk = iStuk-1;
                clear iHdr iStuck;
                break;
            else
                
                %Yep, it was a header, lets store the data and carry on.
                result(iHdr) = temp;
                iHdr = iHdr + 1;
            end
            
        else
            
            % Lets store the data in a structure
            stuk(iStuk).values = cell2mat(temp(1:end-1));
            iStuk = iStuk + 1;
        end   
    end
    
    if numstuk ~=  numhdr, warning('The number of headers and data batches are disimilar.');  end

    
    
    
    % Lets organize the information that we've read in the struct that is
    % used to produce the netcdf file. 
    
    % Time is a special case that should be treated separately
    [~,theIndTime] = find(ismember(cellstr_fields,{'datestring','timestring'}));
    [~,theInd]     = find(~ismember(cellstr_fields,{'datestring','timestring'}));
    
    for istuk = 1:numstuk
        
        % Lets deal with the time first
        if length(theIndTime)==2
            stuk(istuk).values(:,end+1) = time2datenum(stuk(istuk).values(:,theIndTime(1)),stuk(istuk).values(:,theIndTime(2)));
        elseif length(theIndTime)==1
            stuk(istuk).values(:,end+1) = time2datenum(stuk(istuk).values{theIndTime(1)});
        else
            warning('No matlab datenum variable generated')
        end
        
        
        % Sort it by time and store it
        stuk(istuk).values = sortrows(stuk(istuk).values,size(stuk(istuk).values,2));
        result(istuk).data.datenum = stuk(istuk).values(:,end);
        
        
        % Lets deal with the rest of the information in the file
        for icol=theInd,
            
            if strcmpi(cellstr_fields{icol},'variable'), stuk(istuk).values(stuk(istuk).values(:,icol) == 999999999999,icol)= NaN; end
            [~,thefield,~] = getStandardName(cellstr_fields{icol},xls_standard_fields);
            eval(['result(istuk).',thefield,' = stuk(istuk).values(:,icol);']);
        end
        
        result(istuk).source.filename = sourcename;
        result(istuk).ncpath = targetpath;
        
        result(istuk).ncfile = [result(istuk).data.station_name,'_',result(istuk).source.variable_name,'_', ...
                                datestr(min(result(istuk).data.datenum),'yyyymmddTHHMMSS'),'-', ...
                                datestr(max(result(istuk).data.datenum),'yyyymmddTHHMMSS'),'.nc'];
        
        result(istuk).ncfile = strrep(result(istuk).ncfile,'  ','_');
        result(istuk).ncfile = strrep(result(istuk).ncfile,'(','');
        result(istuk).ncfile = strrep(result(istuk).ncfile,')','');
        
        result(istuk).source.institution   = 'Rijkswaterstaat';
        result(istuk).source.url           = 'http://live.waterbase.nl/metis/cgi-bin/mivd.pl?action';
        result(istuk).source.email         = 'helpdeskwater@rws.nl';
        result(istuk).source.version       = '';
        result(istuk).source.comment       = '';
        result(istuk).source.CFfeatureType = 'trajectories';

        result(istuk).source.station_code   = result(istuk).data.station_id;
        result(istuk).source.station_name   = result(istuk).data.station_name;

        result(istuk).tranf2nc.institution  = 'Deltares';
        result(istuk).tranf2nc.author       = 'Ivan Garcia';
        result(istuk).tranf2nc.script       = 'donar_dia2nc.m';
        result(istuk).tranf2nc.version      = '';
        result(istuk).tranf2nc.comment      = 'Beta version, ongoing developments on the script';
        result(istuk).general.title         = '';
        result(istuk).general.terms_for_use = 'These data can be used freely for research purposes provided that the source is acknowledged';
        result(istuk).general.disclaimer    = 'This data is made available in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.';


        result(istuk).data.name = '';
        result(istuk).data.timezone = 'UTC+1';
        result(istuk).data.value_std = [];
        result(istuk).xy_code = 28992;
        result(istuk).xy_name = 'epsg';
        [result(istuk).data.x, result(istuk).data.y] =  convertCoordinates(result(istuk).data.lon,result(istuk).data.lat,'CS1.code',result(istuk).data.coorsystem_code,'CS2.code',result(istuk).xy_code);
        
        struct2nc(result(istuk));
    end
    fclose(fid);
end


function [result] = read_hdr(file_id,standard_names,standard_fields)
    
    rec   = fgetl(file_id);
    
    %-> Check end of file
    if rec == -1, result = -1; return; end
    
    %-> Nope... there is still stuff to read.
    result = ncstruct;
    %-> [WRD] means the start of data lines
    while ~strcmpi(rec(1:5),'[wrd]')
               
        % How many columns in the line?
        numcol = length(strfind(rec,';'));
               
        % Lets create an appropriate reading format.
        % textscan(...,'%f%f%f%s',...)
        theformat = '%s';
        for i=1:numcol,    theformat = ['%s',theformat];     end
               
        if strcmp(rec(1),'[')
            % Non informative unless it is [WRD], which is checked one
            % level up
        else
        
            
            % Read the line
            theinfo = textscan(rec,theformat,'delimiter',';');
                        
            
            % Check the code2name file to see to which struct-field this
            % data corresponds. 
            
            for ifield=2:1:length(theinfo)
                thecode = [theinfo{1}{1},num2str(ifield-1)];
                [~,thefield,~] = getStandardName(thecode,standard_fields)
                
                % Store it only if it is a valid struct-field, the struct
                % field is read from code2name.xls
                if ~strcmp(thecode,thefield)
                    val = getStandardName(theinfo{ifield}{1},standard_names);
                    % disp(['result.',thefield,' = ', val ,';']);
                    eval(['result.',thefield,' = val;']);               
                end
                clear thefield;
            end
        end

        rec   = fgetl(file_id);
        
        
    end
end
function varargout = getStandardName(code,raw)
    
       for i = 2:size(raw,1)
            
           if any(strcmpi(raw(i,:),code))
              varargout{1} = raw{i,2};
              varargout{2} = raw{i,1};
              
              if size(raw,2)>2
                  if ~isnan(raw{i,3})
                     varargout{3} = raw{i,3};
                  else
                     varargout{3} = '';
                  end
              end
              return
           else
              varargout{1} = code;
              varargout{2} = code;
              varargout{3} = code;
           end

       end
       %varargout
end

