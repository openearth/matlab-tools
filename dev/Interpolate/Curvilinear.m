%Class to declare the most common Curvilinear
%
% @author ABR
% @author SEO
% @version 0.8, 10/02/2014
%

classdef Curvilinear < handle
    %Public properties
    properties
        Property1;
    end

    %Dependand properties
    properties (Dependent = true, SetAccess = private)

    end

    %Private properties
    properties(SetAccess = private)

    end

    %Default constructor
    methods
        function obj = Template(property1)
            if nargin > 0
                obj.Property1 = property1;
            end
        end
    end

    %Set methods
    methods
        function set.Property1(obj,property1)
            obj.Property1 = property1;
        end
    end

    %Get methods
    methods
        function property1 = get.Property1(obj)
            property1 = obj.Property1;
        end
    end

    %Public methods
    methods

    end

    %Private methods
    methods (Access = 'private')

    end

    %Stactic methods
    methods (Static)
        function weight = curveLinWeigths(sctQuad,nrQuad,xp,yp)
            i  = nrQuad;
            % determine grid sizes (at cell center)
            dxdu = 0.5.*(sctQuad.x2(i)-sctQuad.x1(i) + sctQuad.x3(i)-sctQuad.x4(i));
            dxdv = 0.5.*(sctQuad.x3(i)-sctQuad.x2(i) + sctQuad.x4(i)-sctQuad.x1(i));
            dydu = 0.5.*(sctQuad.y2(i)-sctQuad.y1(i) + sctQuad.y3(i)-sctQuad.y4(i));
            dydv = 0.5.*(sctQuad.y3(i)-sctQuad.y2(i) + sctQuad.y4(i)-sctQuad.y1(i));

            %jacobian = 1./sqrt(dxdu.*dydv - dydu.*dxdv);
            jacobian = 1./(dxdu.*dydv - dydu.*dxdv);
            % determine the location of the point in grid coordinates
            dx = (xp-sctQuad.x1(i));
            dy = (yp-sctQuad.y1(i));
            pu = jacobian.*(dydv.*dx - dxdv.*dy);
            pv = jacobian.*(-dydu.*dx + dxdu.*dy);
            pu = max(min(pu,1),0);
            pv = max(min(pv,1),0);

            % determine weighting factors
            A1 =(1-pu).*(1-pv);
            A2 = pu   .*(1-pv);
            A3 = pu   .* pv;
            A4 =(1-pu).* pv;

            weight = [A1,A2,A3,A4];
        end;

        function dataOut = curvelinInterp(sctInterp,dataIn)
            % apply interpolation on curvilinear grid
            %
            % dataOut = curvelinInterp(sctInterp,dataIn)
            %
            % INPUT: sctInterp: a structure generated by
            % curvelinInterpPrepare
            %      : dataIn: [MxN] matrix with data to interpolate
            % OUTPUT: dataOut: [Kx1] vector with interpolated data
            dataOut = zeros(sctInterp.nrPoint,1);
            data    = nan(sctInterp.nrPoint,1);
            for i=1:4
                mask       = sctInterp.mask(:,i);
                data(mask) = dataIn(sctInterp.index(mask,i));
                dataOut    = dataOut + sctInterp.weight(:,i).*data;
            end;
        end;

        function sctInterp = curvelinInterpPrepare(xGrid,yGrid,xp,yp)
            % prepares interpolation in curvilinear coordinates
            %
            % sctInterp = curvelinInterpPrepare(xGrid,yGrid,xp,yp)
            % 
            % INPUT: xGrid, yGrid: [MxN] matrixes with coordinates of the
            % source grid
            %      xp, yp: [Kx1] vectors with coordinates of the target
            %      destination
            % OUTPUT: sctInterp: a structure for interpolation used in
            % curvelinInterp
            nrPoint = size(xp,1);
            index   = nan(nrPoint,4);
            weight  = nan(nrPoint,4);

            sctQuad = Curvilinear.prepareQuad(xGrid,yGrid);
            hWait = waitbar(0,'Preparing interpolation ...');
            for i = 1:nrPoint
                % look up for each point the quadrilateral
                inQuad = Curvilinear.inQuad(xp(i),yp(i),sctQuad);
                nrGridCell =   find(inQuad,1,'first');
                if ~isempty(nrGridCell)
                    index(i,1) = sctQuad.i1(nrGridCell);
                    index(i,2) = sctQuad.i2(nrGridCell);
                    index(i,3) = sctQuad.i3(nrGridCell);
                    index(i,4) = sctQuad.i4(nrGridCell);
                    % detrmine the weighting factors
                    weight(i,:) = Curvilinear.curveLinWeigths(sctQuad,nrGridCell,xp(i),yp(i));
                end;
                % update wiatbar
                if mod(i,round(nrPoint/100))
                    waitbar(i/nrPoint,hWait);
                end;
            end;
            close(hWait)
            % copy data to output
            sctInterp.nrPoint = nrPoint;
            sctInterp.mask    = ~isnan(index);
            sctInterp.index   = index;
            sctInterp.weight  = weight;
        end;

        function sctInterp = curvelinInterpPrepareOther(xGrid,yGrid,xp,yp)
            nrPoint = size(xp,1);
            index   = nan(nrPoint,4);
            weight  = nan(nrPoint,4);

            sctQuad = Curvilinear.prepareQuad(xGrid,yGrid);
            nrQuad  = length(sctQuad.x1);

            hWait = waitbar(0,'Preparing interpolation ...');
            for i = 1:nrQuad
                % look up for each point the quadrilateral
                inQuad = Curvilinear.inQuad(xp,yp,sctQuad,i);
                index(inQuad,1) = sctQuad.i1(i);
                index(inQuad,2) = sctQuad.i2(i);
                index(inQuad,3) = sctQuad.i3(i);
                index(inQuad,4) = sctQuad.i4(i);

                % determine the weighting factors
                weight(inQuad,:) = Curvilinear.curveLinWeigths(sctQuad,i,xp(inQuad),yp(inQuad));

                % update wiatbar
                if mod(i,round(nrQuad/100))
                    waitbar(i/nrQuad,hWait);
                end;
            end;
            close(hWait)

            % copy data to output
            sctInterp.nrPoint = nrPoint;
            sctInterp.mask    = ~isnan(index);
            sctInterp.index   = index;
            sctInterp.weight  = weight;
        end;

        function inQuad = inQuad(xp,yp,sctQuad,i)
            % calculate in a point is in a quadrilateral
            % use winding number method

            tol = 1e-15;
            if nargin ==3
                i = 1:length(sctQuad.x1);
            end;

            % determine determinants
            h1 = sign((xp-sctQuad.x1(i)).*(sctQuad.y2(i)-sctQuad.y1(i)) - (sctQuad.x2(i)-sctQuad.x1(i)).*(yp-sctQuad.y1(i))) ;
            h2 = sign((xp-sctQuad.x2(i)).*(sctQuad.y3(i)-sctQuad.y2(i)) - (sctQuad.x3(i)-sctQuad.x2(i)).*(yp-sctQuad.y2(i))) ;
            h3 = sign((xp-sctQuad.x3(i)).*(sctQuad.y4(i)-sctQuad.y3(i)) - (sctQuad.x4(i)-sctQuad.x3(i)).*(yp-sctQuad.y3(i))) ;
            h4 = sign((xp-sctQuad.x4(i)).*(sctQuad.y1(i)-sctQuad.y4(i)) - (sctQuad.x1(i)-sctQuad.x4(i)).*(yp-sctQuad.y4(i))) ;

            % determine if the point is on one of the vertices

             k1 = (sctQuad.x2(i) - xp).*(sctQuad.y1(i)-yp) - (sctQuad.y2(i)-yp).*(sctQuad.x1(i)-xp);
             k2 = (sctQuad.x3(i) - xp).*(sctQuad.y2(i)-yp) - (sctQuad.y3(i)-yp).*(sctQuad.x2(i)-xp);
             k3 = (sctQuad.x4(i) - xp).*(sctQuad.y3(i)-yp) - (sctQuad.y4(i)-yp).*(sctQuad.x3(i)-xp);
             k4 = (sctQuad.x1(i) - xp).*(sctQuad.y4(i)-yp) - (sctQuad.y1(i)-yp).*(sctQuad.x4(i)-xp);




            onLine  = (abs(k1)<tol) | (abs(k2)<tol) | (abs(k3)<tol) | (abs(k4)<tol);

            % determine if the point is inside
            inQuad = (sign(h1) == sign(h2)) & (sign(h2) == sign(h3)) & (sign(h3) == sign(h4));
            % include lines on the line
            inQuad = inQuad | onLine;
        end;

        function index  = linearIndex(sizeGrid)
            % makes a matrix that for each point gives its linear index
            firstInd  = repmat((1:sizeGrid(1))',1,sizeGrid(2));
            secondInd = repmat(0:sizeGrid(2)-1,sizeGrid(1),1);

            index = firstInd + (secondInd).*sizeGrid(1);
        end;

        function sctQuad = prepareQuad(X,Y)
            % determines polygon coordinates from a grid
            sctQuad.x1 = X(1:end-1,1:end-1); %xi,j
            sctQuad.x2 = X(2:end,1:end-1);   %xi+1,j
            sctQuad.x3 = X(2:end,2:end);     %xi+1,j+1
            sctQuad.x4 = X(1:end-1,2:end);   %x1,j+1
            sctQuad.y1 = Y(1:end-1,1:end-1);
            sctQuad.y2 = Y(2:end,1:end-1);
            sctQuad.y3 = Y(2:end,2:end);
            sctQuad.y4 = Y(1:end-1,2:end);

            % determine grid indices of the polygons
            sizeGrid = size(X);
            index = Curvilinear.linearIndex(sizeGrid);
            sctQuad.i1 = index(1:end-1,1:end-1); %xi,j
            sctQuad.i2 = index(2:end,1:end-1);   %xi+1,j
            sctQuad.i3 = index(2:end,2:end);     %xi+1,j+1
            sctQuad.i4 = index(1:end-1,2:end);   %x1,j+1

            % convert to 1d vectors
            field = fieldnames(sctQuad);
            for i=1:length(field)
                sctQuad.(field{i}) = sctQuad.(field{i})(:);
            end;
        end;

        function testInQuad()
            [X,Y] = meshgrid(0:2,0:2);
            sctQuad = Curvilinear.prepareQuad(X,Y);

            xp = 0:0.5:3;
            yp = 0:0.5:3;

            tic;
            for i=1:length(xp)
                inQuad = Curvilinear.inQuad(xp(i),yp(i),sctQuad);
                disp([xp(i), yp(i),find(inQuad)]);
            end;
            toc;
        end;

    end
end