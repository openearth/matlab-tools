<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>WAFO. Description of kdebin</title>
  <meta name="keywords" content="kdebin">
  <meta name="description" content=" Binned Kernel Density Estimator.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">wafo</a> &gt; <a href="index.html">kdetools</a> &gt; kdebin.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for wafo\kdetools&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>kdebin
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong> Binned Kernel Density Estimator.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong> f = kdebin(A,options,xlo,xup) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> <a href="kdebin.html" class="code" title=" Binned Kernel Density Estimator. ">KDEBIN</a> Binned Kernel Density Estimator. 
  
  CALL:  f = <a href="kdebin.html" class="code" title=" Binned Kernel Density Estimator. ">kdebin</a>(data,options,xlo,xup) 
  
    f      = pdf structure containing: 
             kernel density estimate evaluated in meshgrid(x1,x2,..). 
    data   = data matrix, size N x D (D = # dimensions ) 
   options = kdeoptions-structure or cellvector of named parameters with 
             corresponding values, see <a href="kdeoptset.html" class="code" title=" Create or alter KDE OPTIONS structure. ">kdeoptset</a> for details. 
  xlo,xup  = vectors specifying the <a href="../../wafo/wstats/range.html" class="code" title="  Calculates the difference between the maximum and minimum values. ">range</a> of f. Must include the <a href="../../wafo/wstats/range.html" class="code" title="  Calculates the difference between the maximum and minimum values. ">range</a> of the 
             data. (default min(data)-<a href="../../wafo/wstats/range.html" class="code" title="  Calculates the difference between the maximum and minimum values. ">range</a>(data)/4, max(data)-<a href="../../wafo/wstats/range.html" class="code" title="  Calculates the difference between the maximum and minimum values. ">range</a>(data)/4) 
             If a single value of xlo or xup is given then the <a href="../../wafo/wstats/range.html" class="code" title="  Calculates the difference between the maximum and minimum values. ">range</a> is 
             the is the same in all directions. 
  
   <a href="kdebin.html" class="code" title=" Binned Kernel Density Estimator. ">KDEBIN</a> gives very fast and accurate kernel density estimate. 
   Notice that densities close to normality appear to be the easiest for 
   the kernel estimator to estimate and that the degree of estimation 
   difficulty increases with skewness, kurtosis and multimodality. 
  
   If D&gt;1 <a href="kdebin.html" class="code" title=" Binned Kernel Density Estimator. ">KDEBIN</a> calculates quantile <a href="../../wafo/misc/levels.html" class="code" title=" Calculates discrete levels given the parameter matrix.">levels</a> by integration. An alternative is  
   to calculate them by ranking the kernel density estimate obtained at the  
   points given in DATA i.e. use the commands  
  
    f    = <a href="kdebin.html" class="code" title=" Binned Kernel Density Estimator. ">kdebin</a>( data , kernel) 
    tmp  = num2cell(data,1); 
    r    = <a href="evalpdf.html" class="code" title=" evaluates a PDF struct by interpolation">evalpdf</a>(f,tmp{:}) 
    f.cl = <a href="qlevels2.html" class="code" title=" Calculates quantile levels which encloses P% of data ">qlevels2</a>(r,f.pl);  
  
   The first is probably best when estimating the pdf and the latter is the 
   easiest and most robust for 2D data when only a contour visualization of  
   the data is needed.   
  
  Examples:  
   data = <a href="../../wafo/wstats/wraylrnd.html" class="code" title=" Random matrices from a Rayleigh distribution">wraylrnd</a>(1,500,1); 
                                %Box-Cox transform data before estimation 
   f = <a href="kdebin.html" class="code" title=" Binned Kernel Density Estimator. ">kdebin</a>(data,{'L2',.5,'inc',64});  
   <a href="../../wafo/trgauss/pdfplot.html" class="code" title=" Plot contents of pdf structures">pdfplot</a>(f) 
                                %Non-parametric transformation 
   g   = <a href="../../wafo/trgauss/cdf2tr.html" class="code" title=" Estimate transformation, g, from observed CDF. ">cdf2tr</a>(<a href="../../wafo/wstats/empdistr.html" class="code" title=" Computes and plots the empirical CDF ">empdistr</a>(data,[],0),mean(data),std(data)); 
   opt = <a href="kdeoptset.html" class="code" title=" Create or alter KDE OPTIONS structure. ">kdeoptset</a>('L2',{g},'inc',64);   
   f1  = <a href="kdebin.html" class="code" title=" Binned Kernel Density Estimator. ">kdebin</a>(data,opt); 
   hold on, <a href="../../wafo/trgauss/pdfplot.html" class="code" title=" Plot contents of pdf structures">pdfplot</a>(f1,'r'), hold off 
  
  See also  <a href="kde.html" class="code" title=" Kernel Density Estimator. ">kde</a>, <a href="kdeoptset.html" class="code" title=" Create or alter KDE OPTIONS structure. ">kdeoptset</a>, <a href="mkernel.html" class="code" title=" Multivariate Kernel Function. ">mkernel</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="../../wafo/trgauss/createpdf.html" class="code" title=" f=createpdf(ndim)">createpdf</a></li></TD>
<TD> PDF class constructor</TD>
</TR>
<TR>
<TD><li><a href="evalpdf.html" class="code" title=" fi = evalpdf(pdf,varargin)">evalpdf</a></li></TD>
<TD> evaluates a PDF struct by interpolation</TD>
</TR>
<TR>
<TD><li><a href="fftce.html" class="code" title=" y = fftce(x)">fftce</a></li></TD>
<TD>  Circulant Embedding of a vector or matrix</TD>
</TR>
<TR>
<TD><li><a href="gridcount.html" class="code" title=" c = gridcount(data,X)">gridcount</a></li></TD>
<TD> D-dimensional histogram using linear binning.</TD>
</TR>
<TR>
<TD><li><a href="kdeoptset.html" class="code" title=" options = kdeoptset(varargin)">kdeoptset</a></li></TD>
<TD> Create or alter KDE OPTIONS structure.</TD>
</TR>
<TR>
<TD><li><a href="mkernel.html" class="code" title=" [z,c]=mkernel(varargin)">mkernel</a></li></TD>
<TD> Multivariate Kernel Function.</TD>
</TR>
<TR>
<TD><li><a href="mkernel2.html" class="code" title=" [z,c]=mkernel(X,kstr)">mkernel2</a></li></TD>
<TD> Multivariate Kernel Function, alternative version.</TD>
</TR>
<TR>
<TD><li><a href="qlevels.html" class="code" title=" [ui, p]=qlevels(pdf,p,x1,x2)">qlevels</a></li></TD>
<TD> Calculates quantile levels which encloses P% of PDF</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/trgauss/tranproc.html" class="code" title=" y = tranproc(x,ff)">tranproc</a></li></TD>
<TD> Transforms process X and up to four derivatives</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datatypes\cell.m">cell</a></li></TD>
<TD>          Create cell array.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\graph2d\@scribehandle\class.m">class</a></li></TD>
<TD>         Create object or return object class.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\imaq\imaq\private\clear.m">clear</a></li></TD>
<TD>         Clear variables and functions from memory.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datatypes\deal.m">deal</a></li></TD>
<TD>          Deal inputs to outputs.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\matfun\@single\det.bi">det</a></li></TD>
<TD>           Determinant.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\@int16\diff.bi">diff</a></li></TD>
<TD>          Difference and approximate derivative.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\lang\error.m">error</a></li></TD>
<TD>         Display message and abort function.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\@logical\fftn.bi">fftn</a></li></TD>
<TD>          N-dimensional discrete Fourier Transform.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\@logical\ifftn.bi">ifftn</a></li></TD>
<TD>         N-dimensional inverse discrete Fourier transform.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\ifftshift.m">ifftshift</a></li></TD>
<TD>     Inverse FFT shift.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\matfun\@single\inv.bi">inv</a></li></TD>
<TD>           Matrix inverse.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datatypes\iscell.m">iscell</a></li></TD>
<TD>        True for cell array.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\iofun\@timer\isequal.m">isequal</a></li></TD>
<TD>       True if arrays are numerically equal.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\linspace.m">linspace</a></li></TD>
<TD>      Linearly spaced vector.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\strfun\@char\lower.bi">lower</a></li></TD>
<TD>         Convert string to lowercase.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\meshgrid.m">meshgrid</a></li></TD>
<TD>      X and Y arrays for 3-D plots.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\ndgrid.m">ndgrid</a></li></TD>
<TD>        Generation of arrays for N-D functions and interpolation.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datatypes\num2cell.m">num2cell</a></li></TD>
<TD>      Convert numeric array into cell array.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\ops\@char\transpose.bi">transpose</a></li></TD>
<TD>     .' Transpose.</TD>
</TR>
</TABLE>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="../../wafo/papers/tutorcom/Chapter3.html" class="code" title="This is a script file.">Chapter3</a></li></TD>
<TD> % CHAPTER3  Demonstrates distributions of wave characteristics</TD>
</TR>
<TR>
<TD><li><a href="hlscv.html" class="code" title=" [h,hvec,score]=hlscv(A,kernel,hvec)">hlscv</a></li></TD>
<TD>  Least Squares Cross-Validation estimate of smoothing parameter</TD>
</TR>
<TR>
<TD><li><a href="hstt.html" class="code" title=" h=hstt(A,kernel,inc,maxit,releps,abseps)">hstt</a></li></TD>
<TD> Scott-Tapia-Thompson estimate of smoothing parameter.</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/papers/rec/recinit.html" class="code" title=" recinit">recinit</a></li></TD>
<TD>  setup all global variables of the RECDEMO</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/papers/wafodemo/wafofig3.html" class="code" title=" wafofig3">wafofig3</a></li></TD>
<TD>  Probability density distributions (pdf) of wave period, Tt,</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/papers/wafodemo/wafofig5.html" class="code" title=" wafofig5">wafofig5</a></li></TD>
<TD>  Joint distribution (pdf) of crest front velocity and wave height:</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/papers/wafodemo/wafofig6.html" class="code" title=" wafofig6">wafofig6</a></li></TD>
<TD>  Joint distribution (pdf) of crest front period, Tcf, and crest amplitude, Ac</TD>
</TR>
</TABLE>

</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="keyword">function</span> f = <a name="_sub0" href="#_subfunctions" class="code">kdebin</a>(A,options,xlo,xup) 
0002 <span class="comment">%KDEBIN Binned Kernel Density Estimator. </span>
0003 <span class="comment">% </span>
0004 <span class="comment">% CALL:  f = kdebin(data,options,xlo,xup) </span>
0005 <span class="comment">% </span>
0006 <span class="comment">%   f      = pdf structure containing: </span>
0007 <span class="comment">%            kernel density estimate evaluated in meshgrid(x1,x2,..). </span>
0008 <span class="comment">%   data   = data matrix, size N x D (D = # dimensions ) </span>
0009 <span class="comment">%  options = kdeoptions-structure or cellvector of named parameters with </span>
0010 <span class="comment">%            corresponding values, see kdeoptset for details. </span>
0011 <span class="comment">% xlo,xup  = vectors specifying the range of f. Must include the range of the </span>
0012 <span class="comment">%            data. (default min(data)-range(data)/4, max(data)-range(data)/4) </span>
0013 <span class="comment">%            If a single value of xlo or xup is given then the range is </span>
0014 <span class="comment">%            the is the same in all directions. </span>
0015 <span class="comment">% </span>
0016 <span class="comment">%  KDEBIN gives very fast and accurate kernel density estimate. </span>
0017 <span class="comment">%  Notice that densities close to normality appear to be the easiest for </span>
0018 <span class="comment">%  the kernel estimator to estimate and that the degree of estimation </span>
0019 <span class="comment">%  difficulty increases with skewness, kurtosis and multimodality. </span>
0020 <span class="comment">% </span>
0021 <span class="comment">%  If D&gt;1 KDEBIN calculates quantile levels by integration. An alternative is  </span>
0022 <span class="comment">%  to calculate them by ranking the kernel density estimate obtained at the  </span>
0023 <span class="comment">%  points given in DATA i.e. use the commands  </span>
0024 <span class="comment">% </span>
0025 <span class="comment">%   f    = kdebin( data , kernel) </span>
0026 <span class="comment">%   tmp  = num2cell(data,1); </span>
0027 <span class="comment">%   r    = evalpdf(f,tmp{:}) </span>
0028 <span class="comment">%   f.cl = qlevels2(r,f.pl);  </span>
0029 <span class="comment">% </span>
0030 <span class="comment">%  The first is probably best when estimating the pdf and the latter is the </span>
0031 <span class="comment">%  easiest and most robust for 2D data when only a contour visualization of  </span>
0032 <span class="comment">%  the data is needed.   </span>
0033 <span class="comment">% </span>
0034 <span class="comment">% Examples:  </span>
0035 <span class="comment">%  data = wraylrnd(1,500,1); </span>
0036 <span class="comment">%                               <span class="comment">%Box-Cox transform data before estimation </span></span>
0037 <span class="comment">%  f = kdebin(data,{'L2',.5,'inc',64});  </span>
0038 <span class="comment">%  pdfplot(f) </span>
0039 <span class="comment">%                               <span class="comment">%Non-parametric transformation </span></span>
0040 <span class="comment">%  g   = cdf2tr(empdistr(data,[],0),mean(data),std(data)); </span>
0041 <span class="comment">%  opt = kdeoptset('L2',{g},'inc',64);   </span>
0042 <span class="comment">%  f1  = kdebin(data,opt); </span>
0043 <span class="comment">%  hold on, pdfplot(f1,'r'), hold off </span>
0044 <span class="comment">% </span>
0045 <span class="comment">% See also  kde, kdeoptset, mkernel </span>
0046  
0047 <span class="comment">% Reference:   </span>
0048 <span class="comment">%  Wand,M.P. and Jones, M.C. (1995)  </span>
0049 <span class="comment">% 'Kernel smoothing' </span>
0050 <span class="comment">%  Chapman and Hall, pp 182-192 </span>
0051 <span class="comment">% </span>
0052 <span class="comment">%  B. W. Silverman (1986)  </span>
0053 <span class="comment">% 'Density estimation for statistics and data analysis'   </span>
0054 <span class="comment">%  Chapman and Hall pp 61--66 </span>
0055  
0056  
0057  
0058 <span class="comment">%Tested on: matlab 5.2, 5.3 </span>
0059 <span class="comment">% History: </span>
0060 <span class="comment">% revised pab Feb 2005 </span>
0061 <span class="comment">%  -moved options into a options structure   </span>
0062 <span class="comment">% revised pab Dec2003 </span>
0063 <span class="comment">% -removed the binning to a separate function, gridcount.   </span>
0064 <span class="comment">% revised pab 05.08.2001 </span>
0065 <span class="comment">% - fixed a bug in the binning of c. </span>
0066 <span class="comment">% - made the binning of c even faster using sparse and binc </span>
0067 <span class="comment">% revised pab 27.04.2001 </span>
0068 <span class="comment">% -added call to mkernel2 </span>
0069 <span class="comment">% revised pab 19.12.2000 </span>
0070 <span class="comment">% - added the possibility that L2 is a cellarray of parametric </span>
0071 <span class="comment">%   or non-parametric transformations (secret option) </span>
0072 <span class="comment">% - fixed a bug in the calculation of xlo and xup </span>
0073 <span class="comment">% revised pab 05.01.2000 </span>
0074 <span class="comment">%  - fixed a bug in back transformation </span>
0075 <span class="comment">% revised pab 17.12.99 </span>
0076 <span class="comment">%  - fixed a bug in back transformation </span>
0077 <span class="comment">% revised pab 09.12.99 </span>
0078 <span class="comment">%  -added alpha,L2 </span>
0079 <span class="comment">% revised pab 5.11.99 </span>
0080 <span class="comment">%  - fixed a bug: changed fftshift to ifftshift </span>
0081 <span class="comment">% revised pab 21.10.99 </span>
0082 <span class="comment">%  - added the possibility that Hs is a smoothing matrix  </span>
0083 <span class="comment">% revised pab 15.10.99 </span>
0084 <span class="comment">%  updated documentation </span>
0085 <span class="comment">% revised pab 21.09.99   </span>
0086 <span class="comment">%  - made it fully general for d dimensions </span>
0087 <span class="comment">%  - improoved gridding </span>
0088 <span class="comment">% adapted from kdfft1 and kdfft2 from kdetools by Christian C. Beardah 1994 </span>
0089  
0090 defaultoptions = <a href="kdeoptset.html" class="code" title=" Create or alter KDE OPTIONS structure. ">kdeoptset</a>;   
0091 <span class="comment">% If just 'defaults' passed in, return the default options in g </span>
0092 <span class="keyword">if</span> ((nargin==1) &amp; (nargout &lt;= 1) &amp;  isequal(A,<span class="string">'defaults'</span>)), 
0093   f = defaultoptions; 
0094   <span class="keyword">return</span> 
0095 <span class="keyword">end</span>   
0096 error(nargchk(1,4, nargin)) 
0097  
0098 [n, d]=size(A); <span class="comment">% Find dimensions of A,  </span>
0099                <span class="comment">% n=number of data points, </span>
0100                <span class="comment">% d=dimension of the data.   </span>
0101 <span class="keyword">if</span> (nargin&lt;2 | isempty(options)) 
0102   options  = defaultoptions; 
0103 <span class="keyword">else</span> 
0104   <span class="keyword">switch</span> lower(class(options)) 
0105    <span class="keyword">case</span> {<span class="string">'char'</span>,<span class="string">'struct'</span>}, 
0106     options = <a href="kdeoptset.html" class="code" title=" Create or alter KDE OPTIONS structure. ">kdeoptset</a>(defaultoptions,options); 
0107    <span class="keyword">case</span> {<span class="string">'cell'</span>} 
0108     
0109       options = <a href="kdeoptset.html" class="code" title=" Create or alter KDE OPTIONS structure. ">kdeoptset</a>(defaultoptions,options{:}); 
0110    <span class="keyword">otherwise</span> 
0111     error(<span class="string">'Invalid options'</span>) 
0112   <span class="keyword">end</span> 
0113 <span class="keyword">end</span> 
0114 kernel   = options.kernel; 
0115 h        = options.hs; 
0116 alpha    = options.alpha; 
0117 inc      = options.inc; 
0118 L2       = options.L2; 
0119 hsMethod = options.hsMethod; 
0120 <span class="keyword">if</span> isempty(h),      h      = zeros(1,d);    <span class="keyword">end</span> 
0121  
0122  
0123  
0124 L22 = cell(1,d); 
0125 k3  = []; 
0126 <span class="keyword">if</span> isempty(L2) 
0127   L2 = ones(1,d);     <span class="comment">% default no transformation </span>
0128 <span class="keyword">elseif</span> iscell(L2)   <span class="comment">% cellarray of non-parametric and parametric transformations </span>
0129   Nl2 = length(L2); 
0130   <span class="keyword">if</span> ~(Nl2==1|Nl2==d), error(<span class="string">'Wrong size of L2'</span>), <span class="keyword">end</span> 
0131   [L22{1:d}] = deal(L2{1:min(Nl2,d)}); 
0132   L2 = ones(1,d); <span class="comment">% default no transformation </span>
0133   <span class="keyword">for</span> ix=1:d, 
0134     <span class="keyword">if</span> length(L22{ix})&gt;1, 
0135       k3=[k3 ix];       <span class="comment">% Non-parametric transformation </span>
0136     <span class="keyword">else</span>  
0137      L2(ix) = L22{ix};  <span class="comment">% Parameter to the Box-Cox transformation </span>
0138     <span class="keyword">end</span> 
0139   <span class="keyword">end</span> 
0140 <span class="keyword">elseif</span> length(L2)==1 
0141   L2=L2(:,ones(1,d)); 
0142 <span class="keyword">end</span> 
0143  
0144  
0145  
0146  
0147 amin = min(A); 
0148 <span class="keyword">if</span> any((amin(L2~=1)&lt;=0))  , 
0149   f=[]; 
0150   error(<span class="string">'DATA cannot be negative or zero when L2~=1'</span>) 
0151 <span class="keyword">end</span> 
0152  
0153 <span class="comment">%new call </span>
0154 lA = A;   
0155  
0156 k1 = find(L2==0); <span class="comment">% logaritmic transformation </span>
0157 <span class="keyword">if</span> any(k1) 
0158   lA(:,k1)=log(A(:,k1)); 
0159 <span class="keyword">end</span> 
0160 k2 = find(L2~=0 &amp; L2~=1); <span class="comment">% power transformation </span>
0161 <span class="keyword">if</span> any(k2) 
0162   lA(:,k2)=sign(L2(ones(n,1),k2)).*A(:,k2).^L2(ones(n,1),k2); 
0163 <span class="keyword">end</span> 
0164 <span class="comment">% Non-parametric transformation </span>
0165 <span class="keyword">for</span> ix = k3, 
0166   lA(:,ix) = <a href="../../wafo/trgauss/tranproc.html" class="code" title=" Transforms process X and up to four derivatives  ">tranproc</a>(A(:,ix),L22{ix}); 
0167 <span class="keyword">end</span> 
0168  
0169 amax = max(lA); 
0170 amin = min(lA); 
0171 xyzrange = amax-amin; 
0172  
0173  
0174  
0175 <span class="keyword">if</span> nargin&lt;3|isempty(xlo) 
0176   xlo=amin-xyzrange/4; 
0177   <span class="keyword">if</span> any(k1) 
0178       xlo(k1)=max(min(.5*log(eps),amin(k1)-eps),xlo(k1)); 
0179   <span class="keyword">end</span>       
0180   <span class="keyword">if</span> any(k2)      
0181     <span class="comment">%xlo(k2)=max(min(sign(L2(k2)).*(eps).^(L2(k2)/2),amin(k2)-eps),xlo(k2) );   </span>
0182     ki=find(xlo(k2)&lt;=0); 
0183     xlo(k2(ki)) = max(sign(L2(k2(ki))).*(eps).^(L2(k2(ki))/2),amin(k2(ki))-eps);  
0184     <span class="comment">%xlo(k2(ki)) = amin(k2(ki))/2; </span>
0185   <span class="keyword">end</span> 
0186   <span class="keyword">for</span> ix = k3, 
0187     xlo(ix) = max(<a href="../../wafo/trgauss/tranproc.html" class="code" title=" Transforms process X and up to four derivatives  ">tranproc</a>(sqrt(eps),L22{ix}),amin(ix)-eps); 
0188   <span class="keyword">end</span> 
0189   xlo = min(xlo,amin); <span class="comment">% make sure xlo&lt;=amin pab 19.12.2000 </span>
0190 <span class="keyword">else</span> 
0191   <span class="keyword">if</span> length(xlo)&lt;d 
0192     xlo=xlo(1)*ones(1,d); 
0193   <span class="keyword">end</span> 
0194   <span class="keyword">if</span> any(k1), xlo(k1)=log(xlo(k1));  <span class="keyword">end</span> 
0195   <span class="keyword">if</span> any(k2), xlo(k2)=sign(L2(k2)).*xlo(k2).^L2(k2);  <span class="keyword">end</span> 
0196   <span class="keyword">for</span> ix = k3, 
0197     xlo(ix) = <a href="../../wafo/trgauss/tranproc.html" class="code" title=" Transforms process X and up to four derivatives  ">tranproc</a>(xlo(ix),L22{ix}); 
0198   <span class="keyword">end</span> 
0199   xlo = min(xlo,amin-eps); <span class="comment">% make sure the range of the data is included </span>
0200 <span class="keyword">end</span> 
0201  
0202 <span class="keyword">if</span> nargin&lt;4|isempty(xup) 
0203   xup=amax+xyzrange/4; 
0204 <span class="keyword">else</span> 
0205   <span class="keyword">if</span> length(xup)&lt;d 
0206     xup=xup(1)*ones(1,d); 
0207   <span class="keyword">end</span> 
0208   <span class="keyword">if</span> any(k1), xup(k1) = log(xup(k1));  <span class="keyword">end</span> 
0209   <span class="keyword">if</span> any(k2), xup(k2) = sign(L2(k2)).*xup(k2).^L2(k2);  <span class="keyword">end</span> 
0210   <span class="keyword">for</span> ix = k3, 
0211     xup(ix) = <a href="../../wafo/trgauss/tranproc.html" class="code" title=" Transforms process X and up to four derivatives  ">tranproc</a>(xup(ix),L22{ix}); 
0212   <span class="keyword">end</span> 
0213   xup = max(xup,amax+eps); <span class="comment">% make sure the range of the data is included </span>
0214 <span class="keyword">end</span> 
0215  
0216  
0217 f = <a href="../../wafo/trgauss/createpdf.html" class="code" title=" PDF class constructor">createpdf</a>(d); 
0218 X = zeros(inc,d); 
0219 <span class="keyword">for</span> ix=1:d 
0220   X(:,ix)=transpose(linspace(xlo(ix),xup(ix),inc)); 
0221   f.x{ix}=X(:,ix); 
0222 <span class="keyword">end</span> 
0223  
0224 hsiz=size(h); 
0225 <span class="keyword">if</span> (min(hsiz)==1)|(d==1) 
0226   <span class="keyword">if</span> max(hsiz)==1, 
0227     h=h*ones(1,d); 
0228   <span class="keyword">else</span> 
0229     h = reshape(h,[1 d]); <span class="comment">% make sure it has the correct shape </span>
0230   <span class="keyword">end</span> 
0231  
0232   ind=find(h&lt;=0); 
0233   <span class="keyword">if</span> any(ind)      <span class="comment">% If no value of h has been specified by the user then  </span>
0234     h(ind)=feval(hsMethod,lA(:,ind),kernel); <span class="comment">% calculate optimal values.   </span>
0235   <span class="keyword">end</span> 
0236   deth = prod(h); 
0237   hvec = h; 
0238   HG   = 0; 
0239 <span class="keyword">else</span> 
0240   deth=det(h); 
0241   <span class="keyword">if</span> deth&lt;=0, 
0242     error(<span class="string">'bandwidth matrix h must be positive definit'</span>) 
0243   <span class="keyword">end</span> 
0244   hvec=diag(h).'; 
0245   h1=inv(h); 
0246   HG=1; 
0247 <span class="keyword">end</span> 
0248 options.hs = h; 
0249  
0250 <span class="comment">% The kernel must be symmetric and compactly supported on [-tau tau] </span>
0251 <span class="comment">% if the kernel has infinite support then the kernel must have  </span>
0252 <span class="comment">% the effective support in [-tau tau], i.e., be negligible outside the range </span>
0253 tau=1; 
0254 <span class="keyword">switch</span> lower(kernel(1:4)) 
0255   <span class="keyword">case</span> <span class="string">'epan'</span>, tstr= <span class="string">'Epanechnikov'</span>;<span class="comment">%  - Epanechnikov kernel. (default) </span>
0256   <span class="keyword">case</span> <span class="string">'biwe'</span>, tstr= <span class="string">'Biweight'</span>; <span class="comment">%     - Bi-weight kernel. </span>
0257   <span class="keyword">case</span> <span class="string">'triw'</span>, tstr= <span class="string">'Triweight'</span>;<span class="comment">%     - Tri-weight kernel.   </span>
0258   <span class="keyword">case</span> <span class="string">'tria'</span>, tstr= <span class="string">'Triangular'</span>;<span class="comment">%    - Triangular kernel. </span>
0259   <span class="keyword">case</span> <span class="string">'gaus'</span>, tstr= <span class="string">'Gaussian'</span>;<span class="comment">%      - Gaussian kernel </span>
0260     tau=4; 
0261   <span class="keyword">case</span> <span class="string">'rect'</span>, tstr= <span class="string">'Rectangular'</span>;<span class="comment">%   - Rectangular kernel.  </span>
0262   <span class="keyword">case</span> <span class="string">'lapl'</span>, tstr= <span class="string">'Laplace'</span>;<span class="comment">%       - Laplace kernel. </span>
0263     tau=7; 
0264   <span class="keyword">case</span> <span class="string">'logi'</span>, tstr= <span class="string">'Logistic'</span>;<span class="comment">%      - Logistic kernel. </span>
0265     tau=7; 
0266 <span class="keyword">end</span> 
0267  
0268 L1 = max(floor(tau*hvec.*(inc-1)./(xyzrange))); 
0269 L  = min(L1,inc-1); 
0270 <span class="keyword">if</span> d&lt;2 
0271   fsiz=[inc,1]; 
0272   nfft=[2*inc,1]; 
0273 <span class="keyword">else</span> 
0274   fsiz=inc*ones(1,d); 
0275   nfft=2*inc.*ones(1,d); 
0276 <span class="keyword">end</span> 
0277  
0278 dx = (xup-xlo)./(inc-1); 
0279 X1 = cell(d,1); 
0280 <span class="keyword">if</span> HG, 
0281     <span class="comment">% new call </span>
0282     X1=num2cell([-L:L]'*dx,1); 
0283     <span class="comment">% X1=num2cell([0:L]'*dx,1); </span>
0284     <span class="keyword">if</span> d&lt;=3, 
0285       [X1{:}]=meshgrid(X1{:}); 
0286     <span class="keyword">else</span>   
0287       disp(<span class="string">'Dimension of data large, this will take a while.'</span>) 
0288       [X1{:}]=ndgrid(X1{:}); 
0289     <span class="keyword">end</span> 
0290      
0291     <span class="keyword">for</span> ix=1:d 
0292       X1{ix}=X1{ix}(:); 
0293     <span class="keyword">end</span> 
0294     X1=num2cell([X1{:}]*h1,1); 
0295     <span class="keyword">for</span> ix=1:d 
0296       X1{ix}=reshape(X1{ix},(2*L+1)*ones(1,d)); 
0297     <span class="keyword">end</span>   
0298 <span class="keyword">else</span> 
0299   <span class="keyword">switch</span> d  
0300     <span class="keyword">case</span> 1, X1{1}=transpose(dx/h*[-L:L]);   
0301     <span class="keyword">case</span> {2,3}  
0302       X1      = num2cell([-L:L]'*(dx./h),1); 
0303       [X1{:}] = meshgrid(X1{:}); 
0304     <span class="keyword">otherwise</span> ,   
0305       disp(<span class="string">'Dimension of data large, this will take a while.'</span>) 
0306       <span class="comment">% new call </span>
0307       X1      = num2cell([-L:L]'*(dx./h),1); 
0308       [X1{:}] = ndgrid(X1{:}); 
0309   <span class="keyword">end</span> 
0310 <span class="keyword">end</span> 
0311 <span class="comment">% Obtain the kernel weights. </span>
0312  
0313 <span class="keyword">if</span> 1 <span class="comment">%HG, <span class="comment">% </span></span>
0314   kw = zeros(nfft); 
0315   indk(1:d) = {(inc-L+1):(inc+L+1)}; 
0316   kw(indk{:}) = <a href="mkernel.html" class="code" title=" Multivariate Kernel Function. ">mkernel</a>(X1{:},kernel)/(n*deth); 
0317   <span class="comment">% Apply 'ifftshift' to the kernel weights, kw. </span>
0318   kw = ifftshift(kw); 
0319 <span class="keyword">else</span> 
0320   kw1 = zeros(floor(nfft/2)+1);   
0321   indk(1:d)  = {1:(L+1)}; 
0322   kw1(indk{:}) = <a href="mkernel.html" class="code" title=" Multivariate Kernel Function. ">mkernel</a>(X1{:},kernel)/(n*deth); 
0323   kw = <a href="fftce.html" class="code" title="  Circulant Embedding of a vector or matrix">fftce</a>(kw1); <span class="comment">% circulant embedding </span>
0324   clear kw1  
0325 <span class="keyword">end</span> 
0326  
0327 <span class="comment">% Find the binned kernel weights, c. </span>
0328 c = <a href="gridcount.html" class="code" title=" D-dimensional histogram using linear binning. ">gridcount</a>(lA,X); 
0329  
0330 <span class="comment">% Perform the convolution. </span>
0331 z = real(ifftn(fftn(c,nfft).*fftn(kw))); 
0332 clear kw 
0333  
0334 <span class="comment">% New call pab 19.04.2001 </span>
0335 <span class="comment">%indk = repmat({1:inc}, d, 1); <span class="comment">% initialize subscripts </span></span>
0336 indk(1:d) = {1:inc};  <span class="comment">% alternatively </span>
0337 f.f = z(indk{:}).*(z(indk{:})&gt;0); 
0338 clear z indk 
0339  
0340 <span class="comment">%f.kernel=tstr; </span>
0341 <span class="comment">%f.hs=h; </span>
0342  
0343 <span class="keyword">if</span> (alpha&gt;0), <span class="comment">% adaptive kde </span>
0344   f.f=f.f(:);  
0345   indc=transpose(find(c&gt;0)); 
0346  
0347   <span class="keyword">if</span> 0 <span class="comment">% clipping to make sure lambda do not get too large </span>
0348     minf=sqrt(eps) <span class="comment">% make sure we sum over f.f(xi)&gt;0 </span>
0349     ind=find(f.f(:)&gt;minf);  
0350   <span class="keyword">else</span> 
0351     ind=indc; 
0352   <span class="keyword">end</span> 
0353   <span class="comment">% this gives smaller lambda than kdefun! Why??? </span>
0354   g=exp(sum(log(f.f(ind)))/length(ind(:))); <span class="comment">% geometric mean of f </span>
0355   lambda=ones(fsiz); 
0356   
0357   lambda(ind)=(f.f(ind)/g).^(-alpha); <span class="comment">%  local bandwidth factor  </span>
0358    
0359   
0360   Nx=inc^d; 
0361   f.f=zeros(Nx,1); 
0362   <span class="keyword">switch</span> d  
0363     <span class="keyword">case</span> 1, X1{1}=transpose(dx*[1:inc]);   
0364     <span class="keyword">case</span> {2,3}  
0365       X1=num2cell([1:inc]'*dx,1); 
0366       [X1{:}]=meshgrid(X1{:}); 
0367     <span class="keyword">otherwise</span> ,   
0368       <span class="comment">%disp('Dimension of data large, this will take a while.') </span>
0369       <span class="comment">% new call </span>
0370       X1=num2cell([1:inc]'*dx,1); 
0371       [X1{:}]=ndgrid(X1{:}); 
0372     <span class="keyword">end</span> 
0373     <span class="keyword">for</span> ix=1:d 
0374       X1{ix}=X1{ix}(:); 
0375     <span class="keyword">end</span> 
0376     lX=[X1{:}]; 
0377  
0378   <span class="keyword">if</span> ~HG ,<span class="comment">%(min(hsiz)==1)|(d==1) </span>
0379     lX=lX./h(ones(Nx,1),:);  
0380     <span class="keyword">for</span> ix=indc,<span class="comment">%Sum over all data points </span>
0381       Avec=lX(ix,:); 
0382       Xnn=(lX-Avec(ones(Nx,1),:))/(lambda(ix));   
0383       f.f=f.f+<a href="mkernel2.html" class="code" title=" Multivariate Kernel Function, alternative version. ">mkernel2</a>(Xnn,kernel)*c(ix)/(lambda(ix)^d);<span class="comment">% pab 27.04.01 </span>
0384     <span class="keyword">end</span> 
0385   <span class="keyword">else</span> <span class="comment">% adaptive kde <span class="comment">% fully general </span></span>
0386     <span class="keyword">for</span> ix=indc,<span class="comment">%  Sum over all data points </span>
0387      Avec=lX(ix,:); 
0388      Xnn=(lX-Avec(ones(Nx,1),:))*(h1/lambda(ix)); 
0389      f.f=f.f+<a href="mkernel2.html" class="code" title=" Multivariate Kernel Function, alternative version. ">mkernel2</a>(Xnn,kernel)*c(ix)/(lambda(ix)^d);<span class="comment">% pab 27.04.01 </span>
0390     <span class="keyword">end</span>     
0391   <span class="keyword">end</span> 
0392   f.f=reshape(f.f,fsiz)/(n*deth); 
0393   <span class="comment">%f.alpha=alpha; </span>
0394   f.lambda=lambda; 
0395   f.title=[<span class="string">'Adaptive Binned Kernel density estimate ( '</span>,tstr,<span class="string">' )'</span>]; 
0396 <span class="keyword">else</span> 
0397   f.title=[<span class="string">'Binned Kernel density estimate ( '</span>,tstr,<span class="string">' )'</span>]; 
0398 <span class="keyword">end</span>   
0399  
0400 <span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">% </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
0401 <span class="comment">%        transforming back         <span class="comment">% </span></span>
0402 <span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">%<span class="comment">% </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
0403  
0404  
0405 <span class="keyword">if</span> any(k1)|any(k2)|any(k3), 
0406   X1=cell(d,1); 
0407   <span class="keyword">switch</span> d 
0408     <span class="keyword">case</span> 1,X1{1}=f.x{1}; 
0409     <span class="keyword">case</span> {2 3}, [X1{:}]=meshgrid(f.x{:}); 
0410     <span class="keyword">otherwise</span>, [X1{:}]=ndgrid(f.x{:}); 
0411   <span class="keyword">end</span> 
0412   <span class="keyword">if</span> any(k1), <span class="comment">% L2=0 i.e. logaritmic transformation </span>
0413     <span class="keyword">for</span> ix=k1 
0414       f.f=f.f./exp(X1{ix}); 
0415       f.x{ix}=exp(f.x{ix}); 
0416     <span class="keyword">end</span> 
0417     <span class="keyword">if</span> any(max(abs(diff(f.f)))&gt;10) 
0418       disp(<span class="string">'Warning: Numerical problems may have occured due to the logaritmic'</span>) 
0419       disp(<span class="string">'transformation. Check the KDE for spurious spikes'</span>) 
0420     <span class="keyword">end</span> 
0421   <span class="keyword">end</span> 
0422   <span class="keyword">if</span> any(k2) <span class="comment">% L2~=0 i.e. power transformation </span>
0423     <span class="keyword">for</span> ix=k2 
0424       f.f=f.f.*((sign(L2(ix)).*X1{ix}.^(1/L2(ix))).<span class="keyword">...</span> 
0425       .^(L2(ix)-1))*L2(ix)*sign(L2(ix)); 
0426       f.x{ix}=(sign(L2(ix)).*f.x{ix}).^(1/L2(ix)); 
0427     <span class="keyword">end</span> 
0428     <span class="keyword">if</span> any(max(abs(diff(f.f)))&gt;10) 
0429       disp(<span class="string">'Warning: Numerical problems may have occured due to the power'</span>) 
0430       disp(<span class="string">'transformation. Check the KDE for spurious spikes'</span>) 
0431     <span class="keyword">end</span> 
0432   <span class="keyword">end</span> 
0433   <span class="keyword">if</span> any(k3), <span class="comment">% non-parametric transformation </span>
0434     oneC = ones(inc,1); 
0435     oneD = ones(1,d); 
0436     <span class="keyword">for</span> ix=k3 
0437       gn  = L22{ix};  
0438       Gn  = fliplr(L22{ix}); 
0439       x0  = <a href="../../wafo/trgauss/tranproc.html" class="code" title=" Transforms process X and up to four derivatives  ">tranproc</a>(f.x{ix},Gn); 
0440       <span class="keyword">if</span> any(isnan(x0)), 
0441     error(<span class="string">'The transformation does not have a strictly positive derivative.'</span>) 
0442       <span class="keyword">end</span> 
0443       hg1  = <a href="../../wafo/trgauss/tranproc.html" class="code" title=" Transforms process X and up to four derivatives  ">tranproc</a>([x0 oneC],gn); 
0444       der1 = abs(hg1(:,2)); <span class="comment">% dg(X)/dX = 1/(dG(Y)/dY) </span>
0445       <span class="comment">% alternative 2 </span>
0446       <span class="comment">%pp  = smooth(Gn(:,1),Gn(:,2),1,[],1); </span>
0447       <span class="comment">%dpp = diffpp(pp); </span>
0448       <span class="comment">%der1 = 1./abs(ppval(dpp,f.x{ix})); </span>
0449       <span class="comment">% Alternative 3 </span>
0450       <span class="comment">%pp  = smooth(gn(:,1),gn(:,2),1,[],1); </span>
0451       <span class="comment">%dpp = diffpp(pp); </span>
0452       <span class="comment">%<span class="comment">%plot(hg1(:,1),der1-abs(ppval(dpp,x0))) </span></span>
0453       <span class="comment">%der1 = abs(ppval(dpp,x0)); </span>
0454       <span class="keyword">if</span> any(der1&lt;=0),  
0455     error([<span class="string">'The transformation must have a strictly positive derivative'</span>]) 
0456       <span class="keyword">end</span> 
0457      
0458       <span class="keyword">switch</span> d, 
0459     <span class="keyword">case</span> 1,  f.f = f.f.*der1; 
0460     <span class="keyword">case</span> {2,3}, 
0461       oneD(ix)  = inc;  
0462       oneD(1:2) = oneD(2:-1:1);       
0463       f.f = f.f.*repmat(reshape(der1,oneD),inc+1-oneD); 
0464       oneD(1:2) = oneD(2:-1:1); 
0465       oneD(ix)  = 1; 
0466     <span class="keyword">otherwise</span> 
0467       oneD(ix) = inc; 
0468       f.f = f.f.*repmat(reshape(der1,oneD),inc+1-oneD) 
0469        oneD(ix) = 1; 
0470       <span class="keyword">end</span> 
0471        
0472       f.x{ix} = x0; 
0473     <span class="keyword">end</span> 
0474     <span class="keyword">if</span> any(max(abs(diff(f.f)))&gt;10) 
0475       disp(<span class="string">'Warning: Numerical problems may have occured due to the power'</span>) 
0476       disp(<span class="string">'transformation. Check the KDE for spurious spikes'</span>) 
0477     <span class="keyword">end</span> 
0478   <span class="keyword">end</span> 
0479   <span class="keyword">if</span> 1 
0480   tmp=f; 
0481  <span class="comment">% pdfplot(f) </span>
0482   <span class="keyword">for</span> ix=[k1 k2 k3] 
0483     f.x{ix}=transpose(linspace(f.x{ix}(1),f.x{ix}(<span class="keyword">end</span>),inc)); 
0484   <span class="keyword">end</span> 
0485   <span class="keyword">switch</span> d 
0486     <span class="keyword">case</span> 1,X1{1}=f.x{1}; 
0487     <span class="keyword">case</span> {2 3}, [X1{:}] = meshgrid(f.x{:}); 
0488     <span class="keyword">otherwise</span>,  [X1{:}] = ndgrid(f.x{:}); 
0489   <span class="keyword">end</span> 
0490   <span class="comment">% interpolating to obtain equidistant grid </span>
0491   <span class="keyword">if</span> 1, 
0492     f.f = <a href="evalpdf.html" class="code" title=" evaluates a PDF struct by interpolation">evalpdf</a>(tmp,X1{:},<span class="string">'linear'</span>); 
0493   <span class="keyword">else</span> 
0494     tmp.f = log(tmp.f+eps); 
0495     f.f=max(exp(<a href="evalpdf.html" class="code" title=" evaluates a PDF struct by interpolation">evalpdf</a>(tmp,X1{:},<span class="string">'spline'</span>))-eps,0); 
0496   <span class="keyword">end</span> 
0497   clear tmp X1 
0498   <span class="keyword">end</span> 
0499   <span class="comment">%who </span>
0500 <span class="keyword">end</span> 
0501 f.note   = f.title; 
0502 <span class="comment">%f.kernel = tstr; </span>
0503 <span class="comment">%f.alpha  = alpha; </span>
0504 <span class="comment">%f.l2     = L2; </span>
0505 f.options = options; 
0506 f.n      = n; 
0507 <span class="keyword">if</span> d&gt;1 
0508   [ql PL] = <a href="qlevels.html" class="code" title=" Calculates quantile levels which encloses P% of PDF ">qlevels</a>(f.f); 
0509   f.cl = ql; 
0510   f.pl = PL; 
0511 <span class="keyword">end</span> 
0512  
0513  
0514  
0515  
0516  
0517  
0518  
0519</pre></div>
<HR noShade>
<SMALL><A href="http://www.maths.lth.se/matstat/">Mathematical 
Statistics</A><BR><A href="http://www.maths.lth.se/">Centre for Mathematical 
Sciences</A><BR><A href="http://www.lu.se/">Lund University</A> with <A 
href="http://www.lth.se/">Lund Institute of Technology</A> </SMALL>
<P><SMALL>Comments or corrections to the <A
href="mailto:wafo@maths.lth.se">WAFO group</A>  </P>

<hr><address>Generated on Thu 06-Oct-2005 02:21:16
 for <strong><A href="http://www.maths.lth.se/matstat/wafo/">WAFO</A></strong>
 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>