<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>WAFO. Description of hste</title>
  <meta name="keywords" content="hste">
  <meta name="description" content=" 2-Stage Solve the Equation estimate of smoothing parameter.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">wafo</a> &gt; <a href="index.html">kdetools</a> &gt; hste.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for wafo\kdetools&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>hste
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong> 2-Stage Solve the Equation estimate of smoothing parameter.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong> h=hste(A,kernel,h,inc,maxit,releps,abseps) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> <a href="hste.html" class="code" title=" 2-Stage Solve the Equation estimate of smoothing parameter. ">HSTE</a> 2-Stage Solve the Equation estimate of smoothing parameter. 
  
  CALL:  hs = <a href="hste.html" class="code" title=" 2-Stage Solve the Equation estimate of smoothing parameter. ">hste</a>(data,kernel,h0) 
   
        hs = one dimensional value for smoothing parameter 
             given the data and kernel.  size 1 x D 
    data   = data matrix, size N x D (D = # dimensions ) 
    kernel = 'gaussian'  - Gaussian kernel (default) 
              ( currently the only supported kernel) 
        h0 = initial starting guess for hs (default h0=<a href="hns.html" class="code" title=" Normal Scale Estimate of Smoothing Parameter. ">hns</a>(A,kernel)) 
  
   Example:  
    x  = <a href="../../wafo/wstats/wnormrnd.html" class="code" title=" Random matrices from a Normal distribution.">wnormrnd</a>(0,1,50,1); 
    hs = <a href="hste.html" class="code" title=" 2-Stage Solve the Equation estimate of smoothing parameter. ">hste</a>(x,'gauss'); 
  
  See also  <a href="hbcv.html" class="code" title="  Biased Cross-Validation estimate of smoothing parameter. ">hbcv</a>, <a href="hboot.html" class="code" title="  Bootstrap cross-validation estimate of smoothing parameter. ">hboot</a>, <a href="hos.html" class="code" title=" Oversmoothing Parameter. ">hos</a>, <a href="hldpi.html" class="code" title=" L-stage Direct Plug-In estimate of smoothing parameter. ">hldpi</a>, <a href="hlscv.html" class="code" title="  Least Squares Cross-Validation estimate of smoothing parameter ">hlscv</a>, <a href="hscv.html" class="code" title=" Smoothed cross-validation estimate of smoothing parameter. ">hscv</a>, <a href="hstt.html" class="code" title=" Scott-Tapia-Thompson estimate of smoothing parameter. ">hstt</a>, <a href="kde.html" class="code" title=" Kernel Density Estimator. ">kde</a>, <a href="kdefun.html" class="code" title="  Kernel Density Estimator. ">kdefun</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="deriv.html" class="code" title=" [varargout]=deriv(t,k)">deriv</a></li></TD>
<TD>  4th, 6th, 8th and 10th derivatives of the kernel function.</TD>
</TR>
<TR>
<TD><li><a href="gridcount.html" class="code" title=" c = gridcount(data,X)">gridcount</a></li></TD>
<TD> D-dimensional histogram using linear binning.</TD>
</TR>
<TR>
<TD><li><a href="hns.html" class="code" title=" h=hns(A,kernel)">hns</a></li></TD>
<TD> Normal Scale Estimate of Smoothing Parameter.</TD>
</TR>
<TR>
<TD><li><a href="kernelstats.html" class="code" title=" [mu2, R, Rdd] = kernelstats(kernel)">kernelstats</a></li></TD>
<TD> Return 2'nd order moment of kernel pdf</TD>
</TR>
<TR>
<TD><li><a href="qlevels2.html" class="code" title=" [q, p]=qlevels2(r,p,method)">qlevels2</a></li></TD>
<TD> Calculates quantile levels which encloses P% of data</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\@int16\diff.bi">diff</a></li></TD>
<TD>          Difference and approximate derivative.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\@logical\fft.bi">fft</a></li></TD>
<TD>           Discrete Fourier transform.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\@logical\ifft.bi">ifft</a></li></TD>
<TD>          Inverse discrete Fourier transform.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\linspace.m">linspace</a></li></TD>
<TD>      Linearly spaced vector.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\std.m">std</a></li></TD>
<TD>           Standard deviation.</TD>
</TR>
</TABLE>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="hbcv2.html" class="code" title=" h=hbcv2(A,kernel)">hbcv2</a></li></TD>
<TD> Biased Cross-Validation smoothing parameter for 2D data.</TD>
</TR>
</TABLE>

</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>001 <span class="keyword">function</span> h=<a name="_sub0" href="#_subfunctions" class="code">hste</a>(A,kernel,h,inc,maxit,releps,abseps) 
002 <span class="comment">%HSTE 2-Stage Solve the Equation estimate of smoothing parameter. </span>
003 <span class="comment">% </span>
004 <span class="comment">% CALL:  hs = hste(data,kernel,h0) </span>
005 <span class="comment">%  </span>
006 <span class="comment">%       hs = one dimensional value for smoothing parameter </span>
007 <span class="comment">%            given the data and kernel.  size 1 x D </span>
008 <span class="comment">%   data   = data matrix, size N x D (D = # dimensions ) </span>
009 <span class="comment">%   kernel = 'gaussian'  - Gaussian kernel (default) </span>
010 <span class="comment">%             ( currently the only supported kernel) </span>
011 <span class="comment">%       h0 = initial starting guess for hs (default h0=hns(A,kernel)) </span>
012 <span class="comment">% </span>
013 <span class="comment">%  Example:  </span>
014 <span class="comment">%   x  = wnormrnd(0,1,50,1); </span>
015 <span class="comment">%   hs = hste(x,'gauss'); </span>
016 <span class="comment">% </span>
017 <span class="comment">% See also  hbcv, hboot, hos, hldpi, hlscv, hscv, hstt, kde, kdefun </span>
018  
019 <span class="comment">% Reference:   </span>
020 <span class="comment">%  B. W. Silverman (1986)  </span>
021 <span class="comment">% 'Density estimation for statistics and data analysis'   </span>
022 <span class="comment">%  Chapman and Hall, pp 57--61 </span>
023 <span class="comment">% </span>
024 <span class="comment">%  Wand,M.P. and Jones, M.C. (1986)  </span>
025 <span class="comment">% 'Kernel smoothing' </span>
026 <span class="comment">%  Chapman and Hall, pp 74--75 </span>
027    
028 <span class="comment">% tested on: matlab 5.2 </span>
029 <span class="comment">% revised pab aug 2005 </span>
030 <span class="comment">% - All kernels supported </span>
031 <span class="comment">% Revised pab dec 2003 </span>
032 <span class="comment">% added todo comments   </span>
033 <span class="comment">% added inc, maxit,abseps,releps as inputs   </span>
034 <span class="comment">% revised pab 16.10.1999 </span>
035 <span class="comment">% added h0 as input </span>
036 <span class="comment">%  the gridding is made much faster </span>
037 <span class="comment">% taken from kdetools   Christian C. Beardah 1995  </span>
038  
039 <span class="comment">% TODO <span class="comment">% NB: this routine can be made faster: </span></span>
040 <span class="comment">% TODO <span class="comment">% replace the iteration in the end with a Newton Raphson scheme </span></span>
041  
042    
043  
044  
045  
046 <span class="keyword">if</span> nargin&lt;2|isempty(kernel) 
047  kernel=<span class="string">'gauss'</span>; 
048 <span class="keyword">end</span> 
049 <span class="keyword">if</span> nargin&lt;3|isempty(h) 
050   h=<a href="hns.html" class="code" title=" Normal Scale Estimate of Smoothing Parameter. ">hns</a>(A,kernel); 
051 <span class="keyword">end</span> 
052 <span class="keyword">if</span> nargin&lt;4 | isempty(inc) 
053   inc=128; 
054 <span class="keyword">end</span> 
055 <span class="keyword">if</span> nargin&lt;5 | isempty(maxit) 
056   maxit = 100; 
057 <span class="keyword">end</span> 
058 <span class="keyword">if</span> nargin&lt;6 | isempty(releps) 
059   releps = 0.01; 
060 <span class="keyword">end</span> 
061 <span class="keyword">if</span> nargin&lt;7 | isempty(abseps) 
062   abseps = 0.0; 
063 <span class="keyword">end</span> 
064 [n, d] = size(A); 
065 <span class="keyword">if</span> (n==1) &amp; (d&gt;1), 
066   A=A.'; 
067   n=d; 
068   d=1; 
069 <span class="keyword">end</span> 
070  
071  
072 <span class="comment">% R   = int(mkernel(x)^2) </span>
073 <span class="comment">% mu2 = int(x^2*mkernel(x)) </span>
074 [mu2,R] = <a href="kernelstats.html" class="code" title=" Return 2'nd order moment of kernel pdf ">kernelstats</a>(kernel); 
075  
076 STEconstant = R /(mu2^(2)*n); 
077  
078  
079 nfft = inc*2; 
080  
081  
082 xmin   = min(A);    <span class="comment">% Find the minimum value of A. </span>
083 xmax   = max(A);    <span class="comment">% Find the maximum value of A. </span>
084 xrange = xmax-xmin; <span class="comment">% Find the range of A. </span>
085  
086 sigmaA = std(A); 
087 iqr = abs(diff(<a href="qlevels2.html" class="code" title=" Calculates quantile levels which encloses P% of data ">qlevels2</a>(A,[75 25]),1,1)); <span class="comment">% interquartile range </span>
088 k = find(iqr&gt;0); 
089 <span class="keyword">if</span> any(k) 
090   sigmaA(k) = min(sigmaA(k), iqr(k)/1.349); 
091 <span class="keyword">end</span> 
092  
093 <span class="comment">% xa holds the x 'axis' vector, defining a grid of x values where  </span>
094 <span class="comment">% the k.d. function will be evaluated. </span>
095  
096 ax1 = xmin-xrange/8; 
097 bx1 = xmax+xrange/8; 
098  
099 kernel2 = <span class="string">'gaus'</span>; <span class="comment">% kernel </span>
100 [mu2,R] = <a href="kernelstats.html" class="code" title=" Return 2'nd order moment of kernel pdf ">kernelstats</a>(kernel2); 
101 STEconstant2 = R /(mu2^(2)*n); 
102 <span class="keyword">for</span> dim = 1:d 
103   s = sigmaA(dim); 
104   ax = ax1(dim); 
105   bx = bx1(dim); 
106    
107   xa = linspace(ax,bx,inc).';  
108   xn = linspace(0,bx-ax,inc); 
109    
110   c = <a href="gridcount.html" class="code" title=" D-dimensional histogram using linear binning. ">gridcount</a>(A(:,dim),xa); 
111    
112   <span class="comment">%deltax = (bx-ax)/(inc-1); </span>
113   <span class="comment">%xn     = (0:(inc-1))*deltax; </span>
114   <span class="comment">%binx   = floor((A(:,dim)-ax)/deltax)+1; </span>
115   <span class="comment">% Obtain grid counts </span>
116   <span class="comment">%c = full(sparse(binx,1,(xa(binx+1)-A(:,dim)),inc,1)+... </span>
117     <span class="comment">%   sparse(binx+1,1,(A(:,dim)-xa(binx)),inc,1))/deltax; </span>
118  
119  
120   <span class="comment">% Step 1 </span>
121   psi6NS = -15/(16*sqrt(pi)*s^7); 
122   psi8NS = 105/(32*sqrt(pi)*s^9); 
123  
124   <span class="comment">% Step 2 </span>
125   [k40,k60] = <a href="deriv.html" class="code" title="  4th, 6th, 8th and 10th derivatives of the kernel function. ">deriv</a>(0,kernel2); 
126   g1 = (-2*k40/(mu2*psi6NS*n))^(1/7); 
127   g2 = (-2*k60/(mu2*psi8NS*n))^(1/9); 
128  
129   <span class="comment">% Estimate psi6 given g2. </span>
130   [kw4,kw6] = <a href="deriv.html" class="code" title="  4th, 6th, 8th and 10th derivatives of the kernel function. ">deriv</a>(xn/g2,kernel2); <span class="comment">% kernel weights. </span>
131   kw   = [kw6,0,kw6([inc:-1:2])].';             <span class="comment">% Apply 'fftshift' to kw. </span>
132   z    = real(ifft(fft(c,nfft).*fft(kw)));     <span class="comment">% convolution. </span>
133   psi6 = sum(c.*z(1:inc))/(n*(n-1)*g2^7); 
134  
135   <span class="comment">% Estimate psi4 given g1. </span>
136   kw4  = <a href="deriv.html" class="code" title="  4th, 6th, 8th and 10th derivatives of the kernel function. ">deriv</a>(xn/g1,kernel2); <span class="comment">% kernel weights. </span>
137   kw   = [kw4,0,kw4([inc:-1:2])]';            <span class="comment">% Apply 'fftshift' to kw. </span>
138   z    = real(ifft(fft(c,nfft).*fft(kw)));    <span class="comment">% convolution. </span>
139   psi4 = sum(c.*z(1:inc))/(n*(n-1)*g1^5); 
140  
141  
142  
143   <span class="comment">% </span>
144   h1    = h(dim); 
145   h_old = 0; 
146   count = 0; 
147    
148   <span class="keyword">while</span> ((abs(h_old-h1)&gt;max(releps*h1,abseps)) &amp; (count &lt; maxit)), 
149     count = count+1; 
150     <span class="comment">% save old value </span>
151     h_old = h1; 
152    
153     <span class="comment">% Step 3 </span>
154     gamma=((2*k40*mu2*psi4*h1^5)/(-psi6*R))^(1/7); 
155  
156     <span class="comment">% Now estimate psi4 given gamma. </span>
157     kw4 = <a href="deriv.html" class="code" title="  4th, 6th, 8th and 10th derivatives of the kernel function. ">deriv</a>(xn/gamma,kernel2); <span class="comment">%kernel weights.  </span>
158     kw  = [kw4,0,kw4([inc:-1:2])]'; <span class="comment">% Apply 'fftshift' to kw. </span>
159     z   = real(ifft(fft(c,nfft).*fft(kw))); <span class="comment">% convolution. </span>
160  
161     psi4Gamma  = sum(c.*z(1:inc))/(n*(n-1)*gamma^5); 
162    
163     <span class="comment">% Step 4 </span>
164     h1 = (STEconstant2/psi4Gamma)^(1/5); 
165   <span class="keyword">end</span>;   
166   <span class="comment">% Kernel other than Gaussian scale bandwidth </span>
167   h1  = h1*(STEconstant/STEconstant2)^(1/5); 
168    
169  
170   <span class="keyword">if</span> count&gt;= maxit 
171     disp(<span class="string">'The obtained value did not converge.'</span>) 
172   <span class="keyword">end</span> 
173   h(dim) = h1; 
174 <span class="keyword">end</span> <span class="comment">% for dim loop</span></pre></div>
<HR noShade>
<SMALL><A href="http://www.maths.lth.se/matstat/">Mathematical 
Statistics</A><BR><A href="http://www.maths.lth.se/">Centre for Mathematical 
Sciences</A><BR><A href="http://www.lu.se/">Lund University</A> with <A 
href="http://www.lth.se/">Lund Institute of Technology</A> </SMALL>
<P><SMALL>Comments or corrections to the <A
href="mailto:wafo@maths.lth.se">WAFO group</A>  </P>

<hr><address>Generated on Thu 06-Oct-2005 02:21:16
 for <strong><A href="http://www.maths.lth.se/matstat/wafo/">WAFO</A></strong>
 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>