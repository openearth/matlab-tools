<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>WAFO. Description of mem</title>
  <meta name="keywords" content="mem">
  <meta name="description" content="  maximum entropy method for estimating the directional distribution">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">wafo</a> &gt; <a href="../index.html">multidim</a> &gt; <a href="index.html">private</a> &gt; mem.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for wafo\multidim\private&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>mem
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>  maximum entropy method for estimating the directional distribution</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong> DS = mem(Sxyn,Gwt,thetai,fi,k) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> <a href="mem.html" class="code" title="  maximum entropy method for estimating the directional distribution ">MEM</a>  maximum entropy method for estimating the directional distribution 
  
  CALL:  DS = <a href="mem.html" class="code" title="  maximum entropy method for estimating the directional distribution ">mem</a>(Sxy,Gwt,thetai,fi,k); 
  
   DS     = Directional distribution (<a href="../../../wafo/spec/spreading.html" class="code" title=" Directional spreading functions">spreading</a> function) size nt x nf 
   Sxy    = matrix of cross spectral densities size m x m x nf 
   Gwt    = matrix of transfer function (abs(Gwt)==1) size m x nt x nf 
   thetai = angle vector length nt 
   fi     = frequency vector length nf 
   k      = index vector to frequencies where Sf&gt;0 length &lt;= nf 
  
   (m  = number of measurement devices) 
   nf  = number frequencies (f or w) 
   nt  = number of angles   (theta)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="mlm.html" class="code" title=" DS = mlm(Sxy,Gwt,thetai,fi,k,opt)">mlm</a></li></TD>
<TD>  maximum likelihood method for estimating the directional distribution</TD>
</TR>
<TR>
<TD><li><a href="normspfn.html" class="code" title=" DS = normspfn(DS,thetai)">normspfn</a></li></TD>
<TD> normalizes the spreading function</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\iofun\@serial\close.m">close</a></li></TD>
<TD>         Close figure.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\@int16\diff.bi">diff</a></li></TD>
<TD>          Difference and approximate derivative.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\graphics\drawnow.m">drawnow</a></li></TD>
<TD>       Flush pending graphics events.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="">fmins</a></li></TD>
<TD></TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\funfun\fminsearch.m">fminsearch</a></li></TD>
<TD>    Multidimensional unconstrained nonlinear minimization (Nelder-Mead).</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="c:\pab\matlab\graphutil\hline.m">hline</a></li></TD>
<TD>         plots horizontal line(s)</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\wavelet\wavelet\@laurpoly\inline.m">inline</a></li></TD>
<TD>        Construct INLINE object.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\strfun\num2str.m">num2str</a></li></TD>
<TD>       Convert number to string. (Fast version)</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\audiovideo\@audiorecorder\pause.m">pause</a></li></TD>
<TD>         Wait for user response.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\@char\permute.bi">permute</a></li></TD>
<TD>       Permute array dimensions.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\matfun\pinv.m">pinv</a></li></TD>
<TD>          Pseudoinverse.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\ident\ident\@iddata\plot.m">plot</a></li></TD>
<TD>          Linear plot.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\graph2d\semilogy.bi">semilogy</a></li></TD>
<TD>      Semi-log scale plot.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\strfun\sprintf.m">sprintf</a></li></TD>
<TD>       Write formatted data to string.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\strfun\str2num.m">str2num</a></li></TD>
<TD>       Convert string matrix to numeric array.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\sub2ind.m">sub2ind</a></li></TD>
<TD>       Linear index from multiple subscripts.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\graph2d\subplot.m">subplot</a></li></TD>
<TD>       Create axes in tiled positions.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\graph2d\title.m">title</a></li></TD>
<TD>         Graph title.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datafun\trapz.m">trapz</a></li></TD>
<TD>         Trapezoidal numerical integration.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\local\version.m">version</a></li></TD>
<TD>       MATLAB version number.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\uitools\waitbar.m">waitbar</a></li></TD>
<TD>       Display wait bar.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\lang\warning.m">warning</a></li></TD>
<TD>       Display warning message; disable or enable warning messages.</TD>
</TR>
</TABLE>
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="../../../wafo/multidim/dat2dspec.html" class="code" title=" [Sd,D,Sw,Fcof,Gwt,Sxy,Sxy1] = dat2dspec2(xn,pos,h,nfft,nt,method,varargin)">dat2dspec</a></li></TD>
<TD> Estimates the directional wave spectrum from timeseries</TD>
</TR>
</TABLE>

</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>001 <span class="keyword">function</span> DS = <a name="_sub0" href="#_subfunctions" class="code">mem</a>(Sxyn,Gwt,thetai,fi,k) 
002 <span class="comment">%MEM  maximum entropy method for estimating the directional distribution </span>
003 <span class="comment">% </span>
004 <span class="comment">% CALL:  DS = mem(Sxy,Gwt,thetai,fi,k); </span>
005 <span class="comment">% </span>
006 <span class="comment">%  DS     = Directional distribution (spreading function) size nt x nf </span>
007 <span class="comment">%  Sxy    = matrix of cross spectral densities size m x m x nf </span>
008 <span class="comment">%  Gwt    = matrix of transfer function (abs(Gwt)==1) size m x nt x nf </span>
009 <span class="comment">%  thetai = angle vector length nt </span>
010 <span class="comment">%  fi     = frequency vector length nf </span>
011 <span class="comment">%  k      = index vector to frequencies where Sf&gt;0 length &lt;= nf </span>
012 <span class="comment">% </span>
013 <span class="comment">%  (m  = number of measurement devices) </span>
014 <span class="comment">%  nf  = number frequencies (f or w) </span>
015 <span class="comment">%  nt  = number of angles   (theta) </span>
016 <span class="comment">%  </span>
017  
018 <span class="comment">%Tested on matlab 6.0   </span>
019 <span class="comment">%History :  </span>
020 <span class="comment">%revised pab Oct-Nov 2002   </span>
021 <span class="comment">%By pab 1999? </span>
022  
023 [m, nt, nf] = size(Gwt); 
024  
025  
026 H   = zeros(m*m,nt,nf); 
027 phi = zeros(m*m,nf); 
028  
029 <span class="comment">% Eliminate meaningless equations such as those determined  </span>
030 <span class="comment">% from the zero co-spectrum and zero quadrature-spectrum. </span>
031 M = 0;  <span class="comment">% M is the number of independent equations </span>
032  
033 dtheta=thetai(2)-thetai(1); 
034 tol = sqrt(eps); <span class="comment">% treshold defining zero for transfer functions </span>
035 <span class="keyword">for</span> ix=1:m 
036   <span class="keyword">for</span> iy=ix:m 
037     Htemp  = Gwt(ix,:,:).*conj(Gwt(iy,:,:));                         
038     <span class="keyword">if</span> (any(any(abs(diff(real(Htemp),1))&gt;tol*dtheta))) 
039       M        = M+1; 
040       phi(M,:) = real(Sxyn(ix,iy,:)); 
041       H(M,:,:) = real(Htemp);  
042     <span class="keyword">end</span> 
043     <span class="keyword">if</span> any(any(abs(diff(imag(Htemp),1))&gt;tol*dtheta) ) 
044       M            = M+1; 
045       phi(M,:) = imag(Sxyn(ix,iy,:)); 
046       H(M,:,:) = imag(Htemp);           
047     <span class="keyword">end</span> 
048   <span class="keyword">end</span> 
049 <span class="keyword">end</span> 
050 M 
051 H   = H(1:M,:,:); 
052 phi = phi(1:M,:); 
053  
054 warningState = warning; 
055 warning off; 
056  
057 <span class="comment">% Constants controlling the calculation </span>
058 coefAbsTol    = 0.1; 
059 coefAbsTol2   = 100; 
060  
061 errorTol      = 0.1;<span class="comment">%sqrt(eps); </span>
062 maxIter       = 25; 
063 Li            = 1 ; <span class="comment">%relaxation parameter </span>
064 maxCoef       = 5000; 
065  
066 display =1; 
067  
068 La(1:M)  = zeros(1,M); <span class="comment">% Lagrange multiplier </span>
069 dLa(1:M) = zeros(1,M); <span class="comment">% [deltaA,deltaB] </span>
070      
071  
072 DS = repmat(1/(2*pi),nt,nf); <span class="comment">% initialize DS </span>
073       
074 h = waitbar(0,<span class="string">'Please wait...MEM calculation'</span>); 
075  
076 <span class="comment">% compute a fast estimate in order to find a good </span>
077 <span class="comment">% starting guess for the Lagrange multipliers  </span>
078 DS0 = log(<a href="mlm.html" class="code" title="  maximum likelihood method for estimating the directional distribution ">mlm</a>(Sxyn,Gwt,thetai,fi,k)); 
079 Oneth = ones(nt,1); 
080  
081 <span class="keyword">for</span> ff=k, <span class="comment">% loop over frequencies where S(f)&gt;0 </span>
082   waitbar(ff/k(<span class="keyword">end</span>),h) 
083      
084   Hj   = H(:,:,ff).';  <span class="comment">%H(1:M,1:nt)  </span>
085   Phij = repmat(phi(1:M,ff).',nt,1);  
086    
087   stop = 0; 
088   count    = 0; 
089   lambda   = Li; <span class="comment">%relaxation parameter   </span>
090   La0 = -[Oneth Hj] \ DS0(:,ff); <span class="comment">% starting guess for the Lagrange multipliers  </span>
091   La(1:M) = La0(2:M+1); 
092   <span class="comment">%La(1:M)  = zeros(1,M); <span class="comment">% Lagrange multiplier </span></span>
093    
094   dLa(1:M) = zeros(1,M); <span class="comment">% [deltaA,deltaB] </span>
095      
096   <span class="comment">%coef(2*N-1:2*N)      = zeros(1,2); <span class="comment">% [a,b] </span></span>
097   <span class="comment">%deltaCoef(2*N-1:2*N) = zeros(1,2); <span class="comment">% [deltaA,deltaB] </span></span>
098    
099   <span class="comment">%size(La),size(Hj)   </span>
100   exponent  = -(Hj*(La.')); 
101   L0     = -max(exponent); <span class="comment">% trick in order to avoid infinities </span>
102   Fn     = exp(L0+exponent); 
103   Dn     = repmat(Fn/(trapz(Fn)*dtheta),1,M); <span class="comment">%Fn(theta|f)/norm(Fn)=Dn(theta|f) </span>
104   PhiHD  = (Phij-Hj).*Dn; 
105   B      = trapz(PhiHD,1)*dtheta; <span class="comment">% 1xM </span>
106      
107   error1 = max(abs(B)); 
108      
109   <span class="keyword">while</span>(~stop), <span class="comment">%<span class="comment">%Use Newton-Raphson iteration to find model. </span></span>
110     count = count+1; 
111             
112     <span class="comment">%A is the jacobian in the Newton iteration. </span>
113     <span class="keyword">for</span> ix=1:M 
114       A(ix,:)  = trapz(PhiHD.*repmat(Hj(:,ix),1,M),1)*dtheta; 
115     <span class="keyword">end</span> 
116        
117     <span class="comment">%A, disp('Hit a key'),pause </span>
118     dLaOld(1:M) = La; 
119     <span class="comment">%dLa(1:M)    = B/(A.'); <span class="comment">% solve eq. 27  </span></span>
120     dLa(1:M)   = B*pinv(A.'); <span class="comment">% solve eq. 27  </span>
121     La(1:M) = La + lambda*dLa; 
122        
123     <span class="keyword">if</span> (maxCoef&lt;inf)  
124       <span class="comment">%This option is not described in Hashimoto,N. (1997). </span>
125       <span class="comment">%Make sure the coefficients do not diverge to infinity </span>
126       k0 = find(abs(La)&gt;maxCoef); 
127       <span class="keyword">if</span> any(k0) 
128     dLa(k0)=(sign(dLa(k0)).*maxCoef-<span class="keyword">...</span> 
129          (La(k0)-lambda*dLa(k0)))/lambda; 
130     La(k0)     = sign(La(k0)).*maxCoef; 
131       <span class="keyword">end</span> 
132     <span class="keyword">end</span> 
133     exponent  = -(Hj*(La.')); 
134     L0     = -max(exponent); <span class="comment">% trick in order to avoid infinities </span>
135     Fn     = exp(L0+exponent); 
136     Dn     = repmat(Fn/(trapz(Fn)*dtheta),1,M); <span class="comment">%Fn(theta|f)/norm(Fn)=Dn(theta|f) </span>
137     PhiHD  = (Phij-Hj).*Dn; 
138     B      = trapz(PhiHD,1)*dtheta; <span class="comment">% 1xM </span>
139      
140      
141     error2 = error1; 
142     error1 = max(abs(B)); 
143        
144     <span class="keyword">if</span> (~any(abs(dLa(1:M))&gt;coefAbsTol)  | (error1 &lt;= errorTol)); 
145       stop = 1; 
146     <span class="keyword">elseif</span> (count&gt;maxIter | ((error2&lt;error1) &amp; <span class="keyword">...</span> 
147                  (any(abs(dLa-dLaOld)&gt;coefAbsTol2) ))), 
148     dLa(1:M) = 0; 
149     La(1:M)  = La0(2:M+1); 
150      
151     <span class="comment">% Coefficients are diverging and error is increasing </span>
152     <span class="comment">% solution: under relax the computation or quit </span>
153     <span class="keyword">if</span>(lambda&gt;Li*2^-4),  
154       lambda   = lambda*0.5; 
155       count    = 0; 
156        
157        
158       Dn     = repmat(1/(2*pi),nt,M); <span class="comment">%Dn(theta|f) </span>
159       PhiHD  = (Phij-Hj).*Dn; 
160       B      = trapz(PhiHD,1)*dtheta; <span class="comment">% 1xM </span>
161       error2 = inf; 
162       error1 = max(abs(B)); 
163     <span class="keyword">else</span> 
164       stop = 1; 
165     <span class="keyword">end</span> 
166       <span class="keyword">end</span> 
167        
168       <span class="keyword">if</span> 0 <span class="comment">%stop, </span>
169       N = 4; 
170       subplot(N,1,1), semilogy(abs(B)+eps,<span class="string">'*'</span>),hline(errorTol), title(<span class="string">'error'</span>) 
171       subplot(N,1,2),plot(dLa,<span class="string">'g*'</span>), hline(coefAbsTol*[-1,1]),title(<span class="string">'deltaCoef'</span>) 
172       subplot(N,1,3), plot(La,<span class="string">'r*'</span>), title(<span class="string">'coef'</span>) 
173       subplot(N,1,4), plot(thetai,Dn), title(<span class="string">'D(theta|f)'</span>) 
174       drawnow,<span class="comment">% </span>
175       disp(<span class="string">'Hit any key'</span>),pause 
176       <span class="keyword">end</span> 
177     <span class="keyword">end</span> <span class="comment">%while Newton-Raphson </span>
178              
179    
180   <span class="keyword">if</span> display&gt;0 
181     disp(sprintf(<span class="string">'f = %g \t \t Error = %g'</span>,fi(ff),error1)) 
182   <span class="keyword">end</span> 
183    
184   exponent  = -(Hj*(La.')); 
185   L0        = -max(exponent); <span class="comment">% trick in order to avoid infinities </span>
186   DS(:,ff)  = exp(L0+exponent); 
187          
188 <span class="keyword">end</span> <span class="comment">% for ff= </span>
189 close(h) 
190 DS = <a href="normspfn.html" class="code" title=" normalizes the spreading function ">normspfn</a>(DS,thetai); 
191  
192 warning(warningState); 
193  
194 <span class="keyword">if</span> (all(abs(DS(:)-DS(1))&lt;sqrt(eps))) 
195   warning(<span class="string">'No main direction found. Check the estimated spectrum!'</span>) 
196 <span class="keyword">end</span> 
197  
198 <span class="keyword">return</span>; <span class="comment">% MEM </span>
199  
200  
201 <span class="keyword">return</span> 
202  
203 <span class="comment">% old call kept just in case </span>
204 [m, nt, nf] = size(Gwt); 
205 <span class="comment">% This method assumes  a directional spreading of the form </span>
206 <span class="comment">%   D(theta|w) = C*exp( qj*La.')  </span>
207 <span class="comment">% where C is a  normalization constant, La is vector of the unknown Lagrange </span>
208 <span class="comment">% multipliers and qj is a cosine/sinus function. </span>
209  
210 <span class="comment">% compute a fast estimate in order to find a good </span>
211 <span class="comment">% starting guess for the Lagrange multipliers  </span>
212 DS0 = log(<a href="mlm.html" class="code" title="  maximum likelihood method for estimating the directional distribution ">mlm</a>(Sxy,Gwt,thetai,fi,k)); 
213  
214 DS = ones(nt,nf)/(2*pi); <span class="comment">% If S(f)==0 then set D(theta,f)=1/(2*pi); </span>
215  
216 ii = [1:m]'*ones(1,m); 
217 jj = ones(m,1)*[1:m]; 
218  
219 [indx, indy] = find(ii &lt; jj);   <span class="comment">% indices to upper triangular array </span>
220 ind = sub2ind([m m],indx,indy); <span class="comment">% convert to linear index </span>
221  
222 Sxy = permute(Sxy,[3,1,2]); 
223 Gwt = permute(Gwt,[2 1 3 ]); 
224  
225  
226  
227 <span class="comment">% Set up the non linear equation to solve or to minimize:  </span>
228 <span class="comment">% int (Pj(ones(nt,1),:)-qj).*repmat(exp(qj*La.'),1,M2) dtheta^2 =0; </span>
229 <span class="comment">% simpson(thetai, (Pj(ones(nt,1),:)-qj).*repmat(exp(qj*La.'),1,M2)).^2=0; </span>
230 eqstr=inline(<span class="string">'((simpson(P1,P2.*repmat(exp(P3*transpose(x)),1,P4))))'</span>,4); 
231  
232 M2 = m*(m-1); M1 = M2/2; 
233  
234 qj = zeros(nt,M2); 
235 La = rand(1,M2)*10-5; <span class="comment">%zeros(1,M2); <span class="comment">% starting guess </span></span>
236 Pj = La; 
237 <span class="keyword">if</span> 0 
238   tmp = thetai(:) * (1:M1); 
239   qj2 = [cos(tmp) sin(tmp)]; 
240   size(qj2) 
241 <span class="keyword">end</span> 
242  
243  
244 <span class="comment">% find matlab version </span>
245 vstr = version; vind = find(vstr==<span class="string">'.'</span>); 
246 vstr = str2num(vstr(1:vind(2)-1)); 
247  
248 Oneth = ones(nt,1); 
249  
250  
251 <span class="keyword">for</span> ix = k, <span class="comment">% looping over non-zero values of S(f) only </span>
252   Pj(1:M1)       = real(Sxy(ix,ind)); 
253   Pj(M1+1:M2)    = imag(Sxy(ix,ind)); 
254   tmp            = Gwt(:,indx,ix).*conj(Gwt(:,indy,ix)); 
255   qj(:,1:M1)     = real(tmp); 
256   qj(:,M1+1:M2)  = imag(tmp); 
257   <span class="comment">%qj2 = qj; </span>
258   <span class="comment">%plot(qj) </span>
259   <span class="comment">%pause </span>
260   <span class="comment">% Find a good starting guess for La based on log(DS_mlm). </span>
261   <span class="keyword">if</span> 1, 
262      La0 = [Oneth qj] \ DS0(:,ix); 
263   <span class="keyword">else</span> 
264     La0 = [Oneth qj(:,[1:2 M1+1:M1+2] )] \ DS0(:,ix); 
265     La  = [La0(2:3).' zeros(1,M1-2) La0(4:5).' zeros(1,M1-2) ] 
266   <span class="keyword">end</span> 
267   <span class="comment">%mans = memfun(La,thetai,Pj(ones(nt,1),:)-qj,qj,M2); </span>
268   <span class="comment">%if any(isnan(mans)),  La = rand(1,M2)*10-5;  end </span>
269    
270   <span class="comment">% find the Lagrange multipliers La  </span>
271   <span class="keyword">if</span> vstr&gt;5.2, <span class="comment">% matlab version 5.3 or higher </span>
272     <span class="comment">%La = fsolve('memfun',La,optimset('fsolve'),thetai,Pj(ones(nt,1),:)-qj,qj,M2); </span>
273     La = fminsearch(<span class="string">'memfun'</span>,La,[],thetai,Pj(ones(nt,1),:)-qj,qj(:,1:M2),M2); 
274     <span class="comment">%La = fminunc('memfun',La,[],thetai,Pj(ones(nt,1),:)-qj,qj,M2) </span>
275   <span class="keyword">else</span>  <span class="comment">% matlab version 5.2 or higher </span>
276     <span class="comment">%La = fsolve('memfun',La,[],[],thetai,Pj(ones(nt,1),:)-qj,qj,M2); </span>
277     La = fmins(<span class="string">'memfun'</span>,La,[],[],thetai,Pj(ones(nt,1),:)-qj,qj(:,1:M2),M2); 
278     <span class="comment">%La = fminu('memfun',La,[],[],thetai,Pj(ones(nt,1),:)-qj,qj,M2) </span>
279     <span class="comment">%La = fmins(eqstr,La,[],[],thetai,Pj(ones(nt,1),:)-qj,qj,M2) </span>
280   <span class="keyword">end</span> 
281    
282   La(isnan(La)) = 0; <span class="comment">% make sure that isnans is zero </span>
283   <span class="comment">%mans2 = memfun(La,thetai,Pj(ones(nt,1),:)-qj,qj,M2); </span>
284    
285   
286   disp([<span class="string">' Finished '</span> num2str(ix) <span class="string">' of '</span> num2str(nf)]) 
287   <span class="comment">%disp(num2str([mans;mans2])) </span>
288   <span class="comment">%disp(num2str(La)) </span>
289   DS(:,ix) = exp(qj*La.'); 
290   <span class="comment">%if sum(abs(mans2)) &gt; 1  La = rand(1,M2)*10-5;  end  </span>
291 <span class="keyword">end</span> 
292 <span class="comment">%Normalize so that int D(theta,f) dtheta = 1 for each f  </span>
293 <span class="comment">%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ </span>
294 DS = <a href="normspfn.html" class="code" title=" normalizes the spreading function ">normspfn</a>(DS,thetai); 
295  
296 <span class="keyword">return</span>; 
297</pre></div>
<HR noShade>
<SMALL><A href="http://www.maths.lth.se/matstat/">Mathematical 
Statistics</A><BR><A href="http://www.maths.lth.se/">Centre for Mathematical 
Sciences</A><BR><A href="http://www.lu.se/">Lund University</A> with <A 
href="http://www.lth.se/">Lund Institute of Technology</A> </SMALL>
<P><SMALL>Comments or corrections to the <A
href="mailto:wafo@maths.lth.se">WAFO group</A>  </P>

<hr><address>Generated on Thu 06-Oct-2005 02:21:16
 for <strong><A href="http://www.maths.lth.se/matstat/wafo/">WAFO</A></strong>
 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>