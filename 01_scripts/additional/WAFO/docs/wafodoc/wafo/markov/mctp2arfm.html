<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>WAFO. Description of mctp2arfm</title>
  <meta name="keywords" content="mctp2arfm">
  <meta name="description" content="  Calculates asymmetric rainflow matrix for a MCTP.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">wafo</a> &gt; <a href="index.html">markov</a> &gt; mctp2arfm.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for wafo\markov&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mctp2arfm
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>  Calculates asymmetric rainflow matrix for a MCTP.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong> [F_rfc,FF,FFr,T] = mctp2arfm(F,c_m) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> <a href="mctp2arfm.html" class="code" title="  Calculates asymmetric rainflow matrix for a MCTP.">MCTP2ARFM</a>  Calculates asymmetric rainflow matrix for a MCTP.
 
  CALL:  [F_rfc]        = <a href="mctp2arfm.html" class="code" title="  Calculates asymmetric rainflow matrix for a MCTP.">mctp2arfm</a>(F);
         [F_rfc,FF,FFr] = <a href="mctp2arfm.html" class="code" title="  Calculates asymmetric rainflow matrix for a MCTP.">mctp2arfm</a>(F,c_m);
 
  F_rfc  = Asymmetric Rainflow Matrix                 [n,n]
  FF     = Cell array of min-Max and Max-min matrices {1,2}
  FFr    = Cell array of min-Max and Max-min matrices {1,2}
 
  F      = Cell array of min-Max and Max-min matrices {1,2}
  F{1,1} = min-Max matrix                             [n,n]
  F{1,2} = Max-min matrix                             [n,n]
  c_m    = Intensity of local minima, switching proc. [1,1]
           (Default: 1)
 
  Calculates the expected Asymmetric RainFlow Matrix (ARFM) for a 
  Markov Chain of Turning Points.  Recursive formulation a'la Igor
  If a matrix F{1,2}=[], then the process will be assumed to be 
  time-reversible.
 
  Example: 
    param = [-1 1 32]; u = <a href="../../wafo/misc/levels.html" class="code" title=" Calculates discrete levels given the parameter matrix.">levels</a>(param);
    F = <a href="mktestmat.html" class="code" title="   Makes test matrices for min-max (and max-min) matrices. ">mktestmat</a>(param,[-0.2 0.2],0.15,2);
    Frfc = <a href="mctp2rfm.html" class="code" title="  Calculates the rainflow matrix for a MCTP.">mctp2rfm</a>({F []});
    Farfc = <a href="mctp2arfm.html" class="code" title="  Calculates asymmetric rainflow matrix for a MCTP.">mctp2arfm</a>({F []});
    <a href="../../wafo/cycles/cmatplot.html" class="code" title=" Plots a cycle matrix, e.g. a rainflow matrix.">cmatplot</a>(u,u,{Frfc Farfc},3)
    sum(sum(abs((Farfc+Farfc')-(Frfc+Frfc')))) % should be zero
 
  See also  <a href="arfm2mctp.html" class="code" title="  Calculates the markov matrix given an asymmetric rainflow matrix. ">arfm2mctp</a>, <a href="smctp2arfm.html" class="code" title="  Calculates the asymmetric rainflow matrix for a SMCTP.">smctp2arfm</a>, <a href="mctp2rfm.html" class="code" title="  Calculates the rainflow matrix for a MCTP.">mctp2rfm</a>, <a href="../../wafo/cycles/cmatplot.html" class="code" title=" Plots a cycle matrix, e.g. a rainflow matrix.">cmatplot</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="mat2tmat.html" class="code" title=" P = mat2tmat(F,def,K)">mat2tmat</a></li></TD>
<TD>  Converts a matrix to a transition matrix.</TD>
</TR>
<TR>
<TD><li><a href="mc2stat.html" class="code" title=" [ro,PP]=mc2stat(P)">mc2stat</a></li></TD>
<TD>  Calculates the stationary distribution for a Markov chain.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\timefun\clock.m">clock</a></li></TD>
<TD>         Current date and time as date vector.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\lang\error.m">error</a></li></TD>
<TD>         Display message and abort function.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\matfun\@single\inv.bi">inv</a></li></TD>
<TD>           Matrix inverse.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\lang\warning.m">warning</a></li></TD>
<TD>       Display warning message; disable or enable warning messages.</TD>
</TR>
</TABLE>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="../../wafo/markov/test/test_markov.html" class="code" title="This is a script file.">test_markov</a></li></TD>
<TD> Quick test of the routines in module 'markov'</TD>
</TR>
</TABLE>

</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="keyword">function</span> [F_rfc,FF,FFr,T] = <a name="_sub0" href="#_subfunctions" class="code">mctp2arfm</a>(F,c_m)
0002 <span class="comment">%MCTP2ARFM  Calculates asymmetric rainflow matrix for a MCTP.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% CALL:  [F_rfc]        = mctp2arfm(F);</span>
0005 <span class="comment">%        [F_rfc,FF,FFr] = mctp2arfm(F,c_m);</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% F_rfc  = Asymmetric Rainflow Matrix                 [n,n]</span>
0008 <span class="comment">% FF     = Cell array of min-Max and Max-min matrices {1,2}</span>
0009 <span class="comment">% FFr    = Cell array of min-Max and Max-min matrices {1,2}</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% F      = Cell array of min-Max and Max-min matrices {1,2}</span>
0012 <span class="comment">% F{1,1} = min-Max matrix                             [n,n]</span>
0013 <span class="comment">% F{1,2} = Max-min matrix                             [n,n]</span>
0014 <span class="comment">% c_m    = Intensity of local minima, switching proc. [1,1]</span>
0015 <span class="comment">%          (Default: 1)</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Calculates the expected Asymmetric RainFlow Matrix (ARFM) for a </span>
0018 <span class="comment">% Markov Chain of Turning Points.  Recursive formulation a'la Igor</span>
0019 <span class="comment">% If a matrix F{1,2}=[], then the process will be assumed to be </span>
0020 <span class="comment">% time-reversible.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% Example: </span>
0023 <span class="comment">%   param = [-1 1 32]; u = levels(param);</span>
0024 <span class="comment">%   F = mktestmat(param,[-0.2 0.2],0.15,2);</span>
0025 <span class="comment">%   Frfc = mctp2rfm({F []});</span>
0026 <span class="comment">%   Farfc = mctp2arfm({F []});</span>
0027 <span class="comment">%   cmatplot(u,u,{Frfc Farfc},3)</span>
0028 <span class="comment">%   sum(sum(abs((Farfc+Farfc')-(Frfc+Frfc')))) <span class="comment">% should be zero</span></span>
0029 <span class="comment">%</span>
0030 <span class="comment">% See also  arfm2mctp, smctp2arfm, mctp2rfm, cmatplot</span>
0031 
0032 <span class="comment">% References:</span>
0033 <span class="comment">%  </span>
0034 <span class="comment">%  P. Johannesson (1999):</span>
0035 <span class="comment">%  Rainflow Analysis of Switching Markov Loads.</span>
0036 <span class="comment">%  PhD thesis, Mathematical Statistics, Centre for Mathematical Sciences,</span>
0037 <span class="comment">%  Lund Institute of Technology.</span>
0038   
0039 <span class="comment">% Tested  on Matlab  5.3</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% History:</span>
0042 <span class="comment">% Revised by PJ  09-Apr-2001</span>
0043 <span class="comment">%   updated for WAFO</span>
0044 <span class="comment">% Created by PJ (Pär Johannesson) 1998</span>
0045 <span class="comment">% Copyright (c) 1997-1998 by Pär Johannesson</span>
0046 <span class="comment">% Toolbox: Rainflow Cycles for Switching Processes V.1.1, 22-Jan-1998</span>
0047 
0048 <span class="comment">% This program used the formulation where the probabilities</span>
0049 <span class="comment">% of the events are calculated using &quot;elementary&quot; events for</span>
0050 <span class="comment">% the MCTP.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% Standing</span>
0053 <span class="comment">%    pS = Max*pS1*pS2*pS3;</span>
0054 <span class="comment">%    F_rfc(i,j) = pS;</span>
0055 <span class="comment">% Hanging</span>
0056 <span class="comment">%    pH = Min*pH1*pH2*pH3;</span>
0057 <span class="comment">%    F_rfc(j,i) = pH;</span>
0058 <span class="comment">%</span>
0059 <span class="comment">% The cond. prob. pS1, pS2, pS3, pH1, pH2, pH3 are calculated using</span>
0060 <span class="comment">% the elementary cond. prob. C, E, R, D, E3, Ch, Eh, Rh, Dh, E3h. </span>
0061 
0062 T(1,:)=clock;
0063 
0064 <span class="comment">% Check input arguments</span>
0065 
0066 ni = nargin;
0067 no = nargout;
0068 error(nargchk(1,2,ni));
0069 
0070 <span class="keyword">if</span> ni &lt; 2
0071   c_m=1;
0072 <span class="keyword">end</span>
0073 
0074 <span class="comment">% Define </span>
0075 
0076 n = length(F{1,1});  <span class="comment">% Number of levels</span>
0077 
0078 <span class="comment">% Normalize the rowsums of F{1,1} to 1  ==&gt;  Q</span>
0079 
0080 Q = F{1,1};     
0081 Q = <a href="mat2tmat.html" class="code" title="  Converts a matrix to a transition matrix.">mat2tmat</a>(Q,1); <span class="comment">% Convert to min-max transition matrix</span>
0082 
0083 <span class="comment">% Normalize the rowsums of F{1,2} to 1  ==&gt;  Qh</span>
0084 
0085 <span class="keyword">if</span> isempty(F{1,2})       <span class="comment">% Time-reversible</span>
0086   Qh = F{1,1}';
0087 <span class="keyword">else</span>                     <span class="comment">% Fh is given</span>
0088   Qh = F{1,2}; 
0089 <span class="keyword">end</span>
0090 
0091 Qh = <a href="mat2tmat.html" class="code" title="  Converts a matrix to a transition matrix.">mat2tmat</a>(Qh,-1); <span class="comment">% Convert to max-min transition matrix</span>
0092 
0093 T(2,:)=clock;
0094 
0095 <span class="comment">% Stationary distribution (=ro) of local minima with transition matrix</span>
0096 <span class="comment">% Qt = Q*Qh = &quot;Transition matrix for min-to-min&quot;</span>
0097 
0098 Qt = Q*Qh;
0099 ro = <a href="mc2stat.html" class="code" title="  Calculates the stationary distribution for a Markov chain.">mc2stat</a>(Qt(1:(n-1),1:(n-1)));  <span class="comment">% Stationary distr., row vector  </span>
0100 ro = [ro 0];  <span class="comment">% Minimum can't reach the highest level</span>
0101 I = find(ro&lt;0);
0102 <span class="keyword">if</span> ~isempty(I)
0103   warning([<span class="string">'Negative elements in ro. Setting to zero!'</span>]);
0104   ro(I) = zeros(size(I));
0105 <span class="keyword">end</span>
0106 
0107 <span class="comment">% Stationary distribution (=roh) of local maxima with transition matrix</span>
0108 <span class="comment">% Qt = Qh*Q = &quot;Transition matrix for max-to-max&quot;</span>
0109 
0110 Qth = Qh*Q;
0111 roh = <a href="mc2stat.html" class="code" title="  Calculates the stationary distribution for a Markov chain.">mc2stat</a>(Qth(2:n,2:n));  <span class="comment">% Stationary distr., row vector  </span>
0112 roh = [0 roh];  <span class="comment">% Maximum can't reach the highest level</span>
0113 I = find(roh&lt;0);
0114 <span class="keyword">if</span> ~isempty(I)
0115   warning([<span class="string">'Negative elements in roh. Setting to zero!'</span>]);
0116   roh(I) = zeros(size(I));
0117 <span class="keyword">end</span>
0118 
0119 T(3,:)=clock;
0120 
0121 <span class="comment">% Create Transition matrices for time-reversed MC</span>
0122 
0123 <span class="comment">% Backward min-to-max</span>
0124 I1 = find(ro&gt;0); 
0125 ro_inv = zeros(1,n); ro_inv(I1) = 1./ro(I1); 
0126 Qr = Qh' .* (ro_inv'*roh);
0127 
0128 <span class="comment">% Backward max-to-min</span>
0129 I1 = find(roh&gt;0); 
0130 roh_inv = zeros(1,n); roh_inv(I1) = 1./roh(I1); 
0131 Qrh = Q' .* (roh_inv'*ro);
0132 
0133 T(4,:)=clock;
0134 
0135 <span class="comment">% Define matrices for going to or above a level</span>
0136 <span class="comment">%R   = fliplr(cumsum(fliplr(Q),2));</span>
0137 <span class="comment">%Rr  = fliplr(cumsum(fliplr(Qr),2));</span>
0138 
0139 <span class="comment">% Define matrices for going to or below a level</span>
0140 <span class="comment">%Rh  = cumsum(Qh,2);</span>
0141 <span class="comment">%Rrh = cumsum(Qrh,2);</span>
0142 
0143 <span class="comment">% Compure min-max and max-min matrices for model</span>
0144 FF{1,1} = diag(ro)*Q;     <span class="comment">% min-max matrix</span>
0145 FF{1,2} = diag(roh)*Qh;   <span class="comment">% max-min matrix</span>
0146 FFr{1,1} = diag(roh)*Qrh; <span class="comment">% min-max matrix (from reversed chain)</span>
0147 FFr{1,2} = diag(ro)*Qr;   <span class="comment">% min-max matrix (from reversed chain)</span>
0148 <span class="comment">% FF and FFr should be identical</span>
0149 
0150 T(5,:)=clock;
0151 
0152 <span class="comment">% Calculate min-max and max-min matrices from input F</span>
0153 <span class="comment">%F1 = F{1,1}; </span>
0154 <span class="comment">%F1 = F1/sum(sum(F1));</span>
0155 <span class="comment">%F1h = F{1,2}; </span>
0156 <span class="comment">%F1h = F1h/sum(sum(F1h));</span>
0157 <span class="comment">% The model FF need not be equal to F</span>
0158 F1=Q; F1h=Qh;
0159 
0160 <span class="comment">% Calculate rainflow matrix </span>
0161 
0162 F_rfc = zeros(n,n);
0163 EYE = eye(n,n);
0164 
0165 <span class="comment">%fprintf(1,'Calculating row ');</span>
0166 <span class="keyword">for</span> i=1:n-1
0167   <span class="comment">%  fprintf(1,'-%1d',i);</span>
0168   
0169   <span class="keyword">for</span> j=i+1:n
0170     
0171     xx = FF{1,1}(i,j);
0172     yy = FF{1,2}(j,i);
0173     
0174     x = Q(i,j)*ro(i);
0175     y = Qh(j,i)*roh(j);
0176     
0177     <span class="comment">%fprintf(1,'x=%f, y=%f, xx=%f, yy=%f\n',x,y,xx,yy);</span>
0178     
0179     <span class="comment">%    Min = sum(F1(i,:));</span>
0180     <span class="comment">%    Max = sum(F1h(j,:));</span>
0181     Min = sum(F1(i,:)+F1h(:,i)')/2;
0182     Max = sum(F1h(j,:)+F1(:,j)')/2;
0183     
0184     Ro = ro(i);    <span class="comment">% Probability of &quot;min=i&quot;</span>
0185     Roh = roh(j);  <span class="comment">% Probability of &quot;max=j&quot;</span>
0186     
0187     <span class="comment">%    fprintf(1,'Min=%f, Max=%f, Ro=%f, Roh=%f\n',Min,Max,Ro,Roh);</span>
0188     
0189     Min = Ro; Max = Roh; <span class="comment">% Just to be sure</span>
0190     
0191     <span class="keyword">if</span> j-i == 1  <span class="comment">% First subdiagonal</span>
0192       
0193       C = y/Min; Ch = x/Max;
0194       D = 0; Dh = 0;
0195       E = 1-y/Min; Eh = 1-x/Max;
0196       R = 0; Rh = 0;
0197       E3 = 1; E3h = 1;
0198       
0199     <span class="keyword">elseif</span> j-i == 2  <span class="comment">% Second subdiagonal</span>
0200       
0201       <span class="comment">% For Part 1 &amp; 2 of cycle</span>
0202       
0203       I  = i+1:j-2;
0204       J  = i+2:j-1;
0205       
0206       e  = 1 - sum(Qr(I,i+2:j),2);
0207       eh = 1 - sum(Qrh(J,i:j-2),2);
0208       
0209       C   = y/Min;
0210       Ch  = x/Max;
0211       d1  = Qr(i,i+1)*(1-Qrh(i+1,i));
0212       D   = d1;
0213       d1h = Qrh(j,j-1)*(1-Qr(j-1,j));
0214       Dh  = d1h;
0215       d0  = sum(Qr(i,i+1:j-1));
0216       E   = 1-d0-y/Min;
0217       d0h = sum(Qrh(j,i+1:j-1));
0218       Eh  = 1-d0h-x/Max;
0219       r1  = Qr(i,i+1)*Qrh(i+1,i);
0220       R   = r1;
0221       r1h = Qrh(j,j-1)*Qr(j-1,j);
0222       Rh  = r1h;
0223       
0224       <span class="comment">% For Part 3 of cycle</span>
0225       
0226       d3  = sum(Q(i,i+1:j-1));
0227       E3 = 1-d3;
0228       d3h = sum(Qh(j,i+1:j-1));
0229       E3h = 1-d3h;
0230       
0231     <span class="keyword">else</span>
0232       
0233       Eye = EYE(1:j-i-2,1:j-i-2);
0234       
0235       <span class="comment">% For Part 1 &amp; 2 of cycle</span>
0236       
0237       I  = i+1:j-2;
0238       J  = i+2:j-1;
0239       A  = Qr(I,J);
0240       Ah = Qrh(J,I);
0241       a  = Qr(i,J);
0242       ah = Qrh(j,I);
0243       b  = Qr(I,j);
0244       bh = Qrh(J,i);
0245       
0246       e  = 1 - sum(Qr(I,i+2:j),2);
0247       eh = 1 - sum(Qrh(J,i:j-2),2);
0248       
0249       Inv = inv(Eye-A*Ah);
0250       C   = y/Min + a*Ah*Inv*b;
0251       Ch  = x/Max + ah*Inv*A*bh;
0252       d1  = Qr(i,i+1)*(1-Qrh(i+1,i));
0253       D   = d1+a*eh+a*Ah*Inv*A*eh;
0254       d1h = Qrh(j,j-1)*(1-Qr(j-1,j));
0255       Dh  = d1h+ah*Inv*e;
0256       d0  = sum(Qr(i,i+1:j-1));
0257       E   = 1-d0-y/Min+a*Ah*Inv*e;
0258       d0h = sum(Qrh(j,i+1:j-1));
0259       Eh  = 1-d0h-x/Max+ah*Inv*A*eh;
0260       r1  = Qr(i,i+1)*Qrh(i+1,i);
0261       R   = r1+a*bh+a*Ah*Inv*A*bh;
0262       r1h = Qrh(j,j-1)*Qr(j-1,j);
0263       Rh  = r1h+ah*Inv*b;
0264       
0265       <span class="comment">% For Part 3 of cycle</span>
0266       
0267       A3  = Q(I,J);
0268       A3h = Qh(J,I);
0269       a3  = Q(i,J);
0270       a3h = Qh(j,I);
0271       e3  = 1 - sum(Q(I,i+2:j-1),2);
0272       e3h = 1 - sum(Qh(J,i+1:j-2),2);
0273       
0274       Inv3 = inv(Eye-A3*A3h);
0275       d3  = sum(Q(i,i+1:j-1));
0276       E3 = 1-d3 + a3*A3h*Inv3*e3;
0277       d3h = sum(Qh(j,i+1:j-1));
0278       E3h = 1-d3h + a3h*Inv3*A3*e3h;
0279       
0280     <span class="keyword">end</span>
0281     
0282     <span class="keyword">if</span> ~(i == 1 &amp; j == n)
0283       
0284       <span class="comment">% Standing</span>
0285       <span class="keyword">if</span> j == n
0286         pS1 = 0; pS2=0; pS3=0;
0287       <span class="keyword">else</span>
0288         
0289         <span class="comment">% Part 1 of cycle</span>
0290         ES = E + C*Dh/(1-Rh);
0291         RS = R + C*Ch/(1-Rh);
0292         pS1 = ES/(1-RS);
0293         
0294         <span class="comment">% Part 2 of cycle</span>
0295         pS2 = Ch/(1-Rh);
0296         
0297         <span class="comment">% Part 3 of cycle</span>
0298         pS3 = E3h;
0299       <span class="keyword">end</span>
0300       
0301       <span class="comment">% Hanging</span>
0302       <span class="keyword">if</span> i == 1
0303         pH1=0; pH2=0; pH3=0;
0304       <span class="keyword">else</span>
0305         
0306         <span class="comment">% Part 1 of cycle</span>
0307         EH = Eh + Ch*D/(1-R);
0308         RH = Rh + Ch*C/(1-R);
0309         pH1 = EH/(1-RH);
0310         
0311         <span class="comment">% Part 2 of cycle</span>
0312         pH2 = C/(1-R);
0313         
0314         <span class="comment">% Part 3 of cycle</span>
0315         pH3 = E3;
0316       <span class="keyword">end</span>
0317       
0318       <span class="comment">% Check </span>
0319       
0320     <span class="keyword">end</span>
0321     
0322     <span class="keyword">if</span> Min == 0 | Max == 0
0323       pS = 0;
0324       pH = 0;
0325     <span class="keyword">elseif</span> ~(i == 1 &amp; j == n)
0326       pS = Max*pS1*pS2*pS3;
0327       pH = Min*pH1*pH2*pH3;
0328     <span class="keyword">else</span> <span class="comment">% i == 1 &amp; j == n</span>
0329       pS = Min*E3; <span class="comment">% = Max*E3h;</span>
0330       pH = 0;
0331       <span class="comment">%     Old code      </span>
0332       <span class="comment">%      pS = 1/2*Min*E3;</span>
0333       <span class="comment">%      pH = 1/2*Max*E3h;</span>
0334     <span class="keyword">end</span>
0335     
0336     F_rfc(i,j) = pS; <span class="comment">% Standing</span>
0337     F_rfc(j,i) = pH; <span class="comment">% Hanging</span>
0338     
0339   <span class="keyword">end</span>
0340 <span class="keyword">end</span>
0341 <span class="comment">%fprintf(1,'\n');</span>
0342 
0343 <span class="comment">% Check negative elements</span>
0344 
0345 [I,J] = find(F_rfc&lt;0);
0346 <span class="keyword">if</span> ~isempty(I)
0347   warning([<span class="string">'Negative elements in F_rfc. Setting to zero!'</span>]);
0348   <span class="keyword">for</span> k = 1: length(I)
0349     F_rfc(I(k),J(k)) = 0;
0350   <span class="keyword">end</span>
0351 <span class="keyword">end</span>
0352 
0353 <span class="comment">% Multiply with  the intensity of local minima for the swithching process</span>
0354 
0355 F_rfc = c_m*F_rfc;
0356 
0357 T(6,:)=clock;
0358 
0359 
0360</pre></div>
<HR noShade>
<SMALL><A href="http://www.maths.lth.se/matstat/">Mathematical 
Statistics</A><BR><A href="http://www.maths.lth.se/">Centre for Mathematical 
Sciences</A><BR><A href="http://www.lu.se/">Lund University</A> with <A 
href="http://www.lth.se/">Lund Institute of Technology</A> </SMALL>
<P><SMALL>Comments or corrections to the <A
href="mailto:wafo@maths.lth.se">WAFO group</A>  </P>

<hr><address>Generated on Thu 06-Oct-2005 02:21:16
 for <strong><A href="http://www.maths.lth.se/matstat/wafo/">WAFO</A></strong>
 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>